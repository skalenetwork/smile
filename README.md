<p align="center">
  <img src="smile.png" alt="SMILE" width="25%" />
</p>





# üòÑ SMILE ‚Äî SIM Mobile Identity for Ledgers

**Turn your SIM card into a crypto wallet. No applets. No passwords. No KYC.**


SMILE is a breakthrough protocol that derives blockchain wallets directly from SIM cards,
using only standard telecom APIs and the trusted cryptography already built into mobile networks.

With SMILE, your SIM card becomes a secure, self-sovereign blockchain identity ‚Äî
seamlessly integrated with the x402 protocol to enable trustless transactions, instant onboarding, 
and hardware-grade wallet security.


> üîê Your phone number is now your wallet identity.

---

## üöÄ What SMILE Does

- üß¨ **Derives a BIP-32/39 HD wallet** from the SIM‚Äôs AKA authentication keys
- üõ∞ **Uses only existing 3G/4G/5G SIM commands** ‚Äî no Java Card or carrier mods
- ü§ù **Cooperates with the carrier** for proof-of-presence via RAND/AUTN
- üîè **HKDF ‚Üí BIP seed ‚Üí master key** ‚Äî all on device, zero exposure of Ki or K
- ü™™ **Optionally carrier-signed tokens (COSE/JWS)** for verifiable attestation

---

## üí° Why It Matters

- **No fragile seed UX** ‚Äî the SIM *is* your root of trust
- **Pay-per-use connectivity**: pay per MB, per minute, per sensor tick
- **Tap-to-transact IoT**: vending machines, EV chargers, drones, kiosks
- **Carrier ‚Üî crypto flywheel**: airtime, rewards, promos ‚Üí on-chain assets
- **Signed operations**: firmware updates, door unlocks, telemetry notarization

> Every SIM becomes a verifiable crypto identity ‚Äî globally deployed, instantly usable.

---

## üß† How It Works

### üîê How SMILE Derives a Wallet

üì∂ **AKA SIM AUTHENTICATE(RAND, AUTN)**  
‚¨áÔ∏è  
üîë ** Take 2G/3G/4G/5G AKA AKA output as keying material ffor HKDF**   
‚¨áÔ∏è  
üßÆ **HKDF** ‚Äî derive pseudorandom seed  
‚¨áÔ∏è  
üå± **SMILE Seed (64 bytes)**  
‚¨áÔ∏è  
ü™ô **BIP-32 / BIP-39** ‚Äî HD wallet generation  
‚¨áÔ∏è  
üíº **HD Wallet Tree ‚Üí xpub / xpriv / addresses**

‚öôÔ∏è Build Once, Smile Everywhere

üß© Runs on phones, modems, IoT, or embedded Linux

üåê Works with 3G, 4G, 5G, eSIM, iSIM

ü™∂ No baseband mods, no root, no side channels

‚ù§Ô∏è Join the Movement

Every SIM card already holds the world‚Äôs largest identity network.
SMILE turns it into the world‚Äôs most universal crypto wallet.

üìû The future of crypto starts with your SIM.



No custom SIMs. No secret sharing. Just standard 3GPP math.

---

## üõ† Reference Implementation

C++ / CMake / vcpkg stack:

- üîπ **OpenSSL** ‚Äî HKDF / HMAC-SHA256
- üîπ **Trezor Crypto** ‚Äî BIP-32 / BIP-39
- üîπ **PC/SC** ‚Äî SIM APDU access
- üîπ **nlohmann/json** ‚Äî serialization

```bash
git clone https://github.com/your-org/smile
cd smile && mkdir build && cd build
cmake .. && make
./smile
```

# BIP32 Master Seed Derivation using Cellular Authentication (2G‚Äì5G)

**Standards:**
- 3GPP TS 33.102 (3G Security Architecture)
- 3GPP TS 33.401 (LTE Security Architecture)
- 3GPP TS 33.501 (5G Security Architecture)
- RFC 5869: HMAC-based Key Derivation Function (HKDF)
- BIP32: Hierarchical Deterministic Wallets

---

## 1. Overview

This specification defines a set of deterministic algorithms for deriving a **BIP32 master seed** using **SIM/USIM/ISIM-based authentication primitives** from mobile communication systems (2G‚Äì5G).

The approach leverages cryptographically secure values generated during cellular authentication ‚Äî such as **SRES**, **Kc**, **CK**, **IK**, **K_ASME**, and **K_SEAF** ‚Äî as entropy sources for the BIP32 root seed.

The final seed derivation uses the standardized **HKDF** function (RFC 5869) over the authentication-derived keying material.

---

## 2. Notation

| Symbol | Meaning |
|---------|----------|
| `RAND` | Random challenge generated by the network |
| `AUTN` | Authentication token |
| `K` | Subscriber permanent key (stored securely in SIM/USIM/ISIM) |
| `OPc` | Operator variant key constant (Milenage parameter) |
| `AMF` | Authentication Management Field |
| `SNN` | Serving Network Name |
| `SRES` | Signed response (2G AKA output) |
| `Kc` | Cipher key (2G AKA output) |
| `CK` | Cipher key (3G/4G/5G AKA output) |
| `IK` | Integrity key (3G/4G/5G AKA output) |
| `AK` | Anonymity key (3G/4G/5G AKA output) |
| `K_ASME` | Access Security Management Entity key (4G) |
| `K_SEAF` | Security Anchor Function key (5G) |
| `HMAC_SHA256(key, data)` | HMAC using SHA-256 |
| `HKDF_Extract(salt, IKM)` | RFC 5869 extract stage |
| `HKDF_Expand(PRK, info, L)` | RFC 5869 expand stage |
| `‚Äñ` | Byte concatenation |

---

## 3. Cryptographic Framework

### 3.1. HKDF (RFC 5869)

Let:
- `IKM` be the input keying material (entropy source)
- `salt` be an optional context string (domain separation)
- `info` be an optional identifier for derived key usage
- `L` be the desired output length (32 bytes)

Then:

```
PRK = HMAC_SHA256(salt, IKM)
OKM = HMAC_SHA256(PRK, info || 0x01)
Seed = OKM[0..31]
```

---

## 4. 2G: deriveBIP32MasterSeed2G

### 4.1. Authentication Source

2G authentication (GSM AKA) yields:

```
(SRES, Kc) = A3/A8(K, RAND)
```

- `SRES`: 32-bit signed response
- `Kc`: 64-bit session key

### 4.2. Input Keying Material (IKM)

```
IKM_2G = SRES || Kc
```

(12 bytes total)

### 4.3. HKDF Context

- Salt = "SMILE|2G|salt|v1"
- Info = "SMILE|2G|seed|v1"

### 4.4. Derivation Equation

```
Seed_2G = HKDF_SHA256(IKM_2G, Salt, Info)
```

### 4.5. Output

- 256-bit (32-byte) seed suitable as BIP32 master seed.
- Entropy source limited (~96 bits), so use only for deterministic derivations, not high-assurance wallet seeds.

---

## 5. 3G: deriveBIP32MasterSeed3G

### 5.1. Authentication Source

3G AKA (Milenage) yields:

```
(RES, CK, IK, AK) = f1..5(K, RAND, OPc, AMF)
```

- `CK`: 128-bit cipher key
- `IK`: 128-bit integrity key

### 5.2. Input Keying Material

```
IKM_3G = CK || IK
```
(256 bits)

### 5.3. Salt Construction

```
ctx = RAND || AUTN || "SMILE|3G|salt|v1"
Salt_3G = SHA256(ctx)
```

### 5.4. HKDF Derivation

```
Seed_3G = HKDF_SHA256(IKM_3G, Salt_3G, "SMILE|3G|seed|v1")
```

### 5.5. Output

- 256-bit BIP32 seed with high entropy (~256 bits).
- Combines network challenge RAND with key material for domain separation.

---

## 6. 4G: deriveBIP32MasterSeed4G

### 6.1. Authentication Source

LTE AKA yields the derived **Access Security Management Entity key** `K_ASME` from `CK` and `IK` using:

```
K_ASME = HMAC_SHA256(CK||IK, FC||SNN||L0||(SQN‚äïAK)||L1)
```

(Per 3GPP TS 33.401 ¬ßA.2.1, with FC = 0x10.)

### 6.2. Input Keying Material

```
IKM_4G = K_ASME
```
(256 bits)

### 6.3. Salt Construction

```
ctx = SNN || "|" || "SMILE|4G|salt|v1"
Salt_4G = SHA256(ctx)
```

### 6.4. HKDF Derivation

```
Seed_4G = HKDF_SHA256(IKM_4G, Salt_4G, "SMILE|4G|seed|v1")
```

### 6.5. Output

- 256-bit BIP32 seed.
- Strong cryptographic entropy, sourced from LTE authentication hierarchy.
- Safe for generating HD wallet roots tied to mobile identity.

---

## 7. 5G: deriveBIP32MasterSeed5G

### 7.1. Authentication Source

5G AKA (TS 33.501) derives the following hierarchy:

```
K_AUSF = HMAC_SHA256(CK||IK, FC||SNN||L0||(SQN‚äïAK)||L1), FC = 0x6A
K_SEAF = HMAC_SHA256(K_AUSF, FC||SNN||L0), FC = 0x6B
```

### 7.2. Input Keying Material

```
IKM_5G = K_SEAF
```

### 7.3. Salt Construction

```
ctx = SNN || "|" || "SMILE|5G|salt|v1"
Salt_5G = SHA256(ctx)
```

### 7.4. HKDF Derivation

```
Seed_5G = HKDF_SHA256(IKM_5G, Salt_5G, "SMILE|5G|seed|v1")
```

### 7.5. Output

- 256-bit master seed (BIP32 m/ root).
- Entropy sourced from 5G key hierarchy (K_SEAF), which derives from K via CK/IK ‚Üí K_AUSF ‚Üí K_SEAF.
- Represents cryptographic coupling between SIM identity and HD wallet seed.

---

## 8. Security Discussion

1. **Entropy:**
    - 2G: ‚â§ 96 bits
    - 3G/4G/5G: ‚â• 256 bits (AES-based + random challenge)

2. **Forward Secrecy:**
    - Each derivation depends on network RAND, ensuring session uniqueness.

3. **Domain Separation:**
    - HKDF salt and info labels include generation and versioning tags (SMILE|xG|...|v1).

4. **Compatibility:**
    - Final output format (32 bytes) matches BIP32 master seed input for:
      ```
      (m, c) = HMAC_SHA512("Bitcoin seed", Seed)
      ```

---

## 9. Example End-to-End Derivation Flow (5G)

```
Step 1: AKA ‚Üí CK, IK, AK, RES
Step 2: K_AUSF = HMAC_SHA256(CK||IK, 0x6A||SNN||L0||(SQN‚äïAK)||L1)
Step 3: K_SEAF = HMAC_SHA256(K_AUSF, 0x6B||SNN||L0)
Step 4: Salt = SHA256(SNN||"|"||"SMILE|5G|salt|v1")
Step 5: Seed = HKDF_SHA256(K_SEAF, Salt, "SMILE|5G|seed|v1")
Output: Seed_5G ‚àà {0,1}^256
```

---

## 10. Implementation Notes

- All HKDF operations use HMAC-SHA256 as the PRF.
- All salts and info strings are ASCII-encoded.
- The seed output can be directly passed to BIP32 as the entropy input for HMAC-SHA512 keychain derivation.

---

## 11. Security Level Summary

| Generation | Entropy Source | Algorithmic Base | Cryptographic Strength |
|-------------|----------------|------------------|------------------------|
| 2G | (SRES‚ÄñKc) | COMP128 / A3/A8 | Weak / Legacy |
| 3G | (CK‚ÄñIK) via Milenage | AES-128 | Strong |
| 4G | K_ASME (HMAC-SHA256) | AES-128 + SHA256 | Strong |
| 5G | K_SEAF (HMAC-SHA256 chain) | AES-128 + SHA256 | Very Strong |

---

## 12. Final Formula Summary

| Function | Final Formula | Output Bits |
|-----------|----------------|--------------|
| `deriveBIP32MasterSeed2G` | `HKDF_SHA256(SRES‚ÄñKc, "SMILE|2G|salt|v1", "SMILE|2G|seed|v1")` | 256 |
| `deriveBIP32MasterSeed3G` | `HKDF_SHA256(CK‚ÄñIK, SHA256(RAND‚ÄñAUTN‚Äñ"SMILE|3G|salt|v1"), "SMILE|3G|seed|v1")` | 256 |
| `deriveBIP32MasterSeed4G` | `HKDF_SHA256(K_ASME, SHA256(SNN‚Äñ"|"‚Äñ"SMILE|4G|salt|v1"), "SMILE|4G|seed|v1")` | 256 |
| `deriveBIP32MasterSeed5G` | `HKDF_SHA256(K_SEAF, SHA256(SNN‚Äñ"|"‚Äñ"SMILE|5G|salt|v1"), "SMILE|5G|seed|v1")` | 256 |



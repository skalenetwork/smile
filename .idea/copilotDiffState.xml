<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.20)&#10;project(smile LANGUAGES C CXX)&#10;&#10;set(CMAKE_TOOLCHAIN_FILE&#10;        &quot;${CMAKE_CURRENT_SOURCE_DIR}/external/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;&#10;        CACHE STRING &quot;Vcpkg toolchain file&quot;)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_EXPORT_COMPILE_COMMANDS ON)&#10;&#10;# Integrate vcpkg&#10;if(DEFINED ENV{VCPKG_ROOT})&#10;    set(CMAKE_TOOLCHAIN_FILE &quot;$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake&quot;&#10;            CACHE STRING &quot;&quot;)&#10;endif()&#10;&#10;find_package(OpenSSL REQUIRED)&#10;find_package(nlohmann_json REQUIRED)&#10;&#10;&#10;add_executable(smile&#10;        # Add all .cpp files in src directory&#10;        $&lt;TARGET_FILE_DIR:smile&gt;/../src/*.cpp&#10;)&#10;&#10;target_include_directories(smile PRIVATE src external/libbtc/include)&#10;&#10;target_link_libraries(smile&#10;        OpenSSL::Crypto&#10;        nlohmann_json::nlohmann_json&#10;)" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.20)&#10;project(smile LANGUAGES C CXX)&#10;&#10;set(CMAKE_TOOLCHAIN_FILE&#10;        &quot;${CMAKE_CURRENT_SOURCE_DIR}/external/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;&#10;        CACHE STRING &quot;Vcpkg toolchain file&quot;)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_EXPORT_COMPILE_COMMANDS ON)&#10;&#10;# Integrate vcpkg&#10;if(DEFINED ENV{VCPKG_ROOT})&#10;    set(CMAKE_TOOLCHAIN_FILE &quot;$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake&quot;&#10;            CACHE STRING &quot;&quot;)&#10;endif()&#10;&#10;find_package(OpenSSL REQUIRED)&#10;find_package(nlohmann_json REQUIRED)&#10;&#10;file(GLOB SRC_FILES &quot;${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp&quot;)&#10;add_executable(smile ${SRC_FILES})&#10;&#10;target_include_directories(smile PRIVATE src external/libbtc/include)&#10;&#10;target_link_libraries(smile&#10;        OpenSSL::Crypto&#10;        nlohmann_json::nlohmann_json&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/external/libbtc/include/libbtc-config.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/external/libbtc/include/libbtc-config.h" />
              <option name="updatedContent" value="// Minimal libbtc-config.h for direct CMake build&#10;#ifndef LIBBTC_CONFIG_H&#10;#define LIBBTC_CONFIG_H&#10;&#10;#define HAVE_CONFIG_H 1&#10;#define PACKAGE_NAME &quot;libbtc&quot;&#10;#define PACKAGE_VERSION &quot;0.0.1&quot;&#10;#define STDC_HEADERS 1&#10;#define HAVE_DLFCN_H 1&#10;#define HAVE_INTTYPES_H 1&#10;#define HAVE_MEMORY_H 1&#10;#define HAVE_STDINT_H 1&#10;#define HAVE_STDLIB_H 1&#10;#define HAVE_STRINGS_H 1&#10;#define HAVE_STRING_H 1&#10;#define HAVE_SYS_STAT_H 1&#10;#define HAVE_SYS_TYPES_H 1&#10;#define HAVE_UNISTD_H 1&#10;&#10;#endif // LIBBTC_CONFIG_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Comp128.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Comp128.h" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="extern void comp128v1(const uint8_t *ki, const uint8_t *rand, uint8_t *sres, uint8_t *kc);&#10;extern void comp128(const uint8_t *ki, const uint8_t *rand, uint8_t *sres, uint8_t *kc);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Milenage.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Milenage.cpp" />
              <option name="updatedContent" value="#include &quot;Milenage.h&quot;&#10;#include &lt;openssl/aes.h&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;vector&gt;&#10;&#10;// Rijndael round constants&#10;static const uint8_t RCON[10] = {&#10;    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b&#10;};&#10;&#10;// Helper function to perform XOR on two byte arrays&#10;static void xor_128(const uint8_t* a, const uint8_t* b, uint8_t* out) {&#10;    for (int i = 0; i &lt; 16; ++i) {&#10;        out[i] = a[i] ^ b[i];&#10;    }&#10;}&#10;&#10;// The core Rijndael encryption function&#10;static void rijndael_encrypt(const uint8_t* key, const uint8_t* data, uint8_t* out) {&#10;    AES_KEY aes_key;&#10;    AES_set_encrypt_key(key, 128, &amp;aes_key);&#10;    AES_encrypt(data, out, &amp;aes_key);&#10;}&#10;&#10;void Milenage::run(const uint8_t* k, const uint8_t* opc, const uint8_t* rand, const uint8_t* sqn, const uint8_t* amf,&#10;                   uint8_t* res, uint8_t* ck, uint8_t* ik, uint8_t* ak, uint8_t* mac_a) {&#10;    uint8_t temp[16];&#10;    uint8_t in1[16];&#10;    uint8_t out1[16];&#10;    uint8_t c1[16] = {0};&#10;    uint8_t c2[16] = {0};&#10;    uint8_t c3[16] = {0};&#10;    uint8_t c4[16] = {0};&#10;    uint8_t c5[16] = {0};&#10;&#10;    c2[15] = 1;&#10;    c3[15] = 2;&#10;    c4[15] = 4;&#10;    c5[15] = 8;&#10;&#10;    // TEMP = E_K(RAND XOR OP_C)&#10;    xor_128(rand, opc, temp);&#10;    rijndael_encrypt(k, temp, out1);&#10;&#10;    // IN1 = SQN || AMF || SQN || AMF&#10;    memcpy(in1, sqn, 6);&#10;    memcpy(in1 + 6, amf, 2);&#10;    memcpy(in1 + 8, sqn, 6);&#10;    memcpy(in1 + 14, amf, 2);&#10;&#10;    // OUT1 = E_K(TEMP XOR IN1)&#10;    xor_128(out1, in1, temp);&#10;    rijndael_encrypt(k, temp, out1);&#10;    // MAC_A = f1 = OUT1[0..7]&#10;    memcpy(mac_a, out1, 8);&#10;&#10;    // RES, CK, IK, AK&#10;    // RES = f2 = OUT1[8..15]&#10;    xor_128(out1, c2, temp);&#10;    rijndael_encrypt(k, temp, out1);&#10;    memcpy(res, out1 + 8, 8);&#10;&#10;    // CK = f3 = OUT1[0..15]&#10;    xor_128(out1, c3, temp);&#10;    rijndael_encrypt(k, temp, ck);&#10;&#10;    // IK = f4 = OUT1[0..15]&#10;    xor_128(out1, c4, temp);&#10;    rijndael_encrypt(k, temp, ik);&#10;&#10;    // AK = f5 = OUT1[0..7]&#10;    xor_128(out1, c5, temp);&#10;    rijndael_encrypt(k, temp, out1);&#10;    memcpy(ak, out1, 6);&#10;}&#10;&#10;void Milenage::f1(const uint8_t* k, const uint8_t* rand, const uint8_t* sqn, const uint8_t* amf, const uint8_t* opc, uint8_t* mac_a, uint8_t* mac_s) {&#10;    // Not fully implemented as run() is used directly&#10;}&#10;&#10;void Milenage::f2345(const uint8_t* k, const uint8_t* rand, const uint8_t* opc, uint8_t* res, uint8_t* ck, uint8_t* ik, uint8_t* ak) {&#10;    // Not fully implemented as run() is used directly&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Milenage.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Milenage.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;cstdint&gt;&#10;#include &lt;vector&gt;&#10;&#10;class Milenage {&#10;public:&#10;    static void f1(const uint8_t* k, const uint8_t* rand, const uint8_t* sqn, const uint8_t* amf, const uint8_t* opc, uint8_t* mac_a, uint8_t* mac_s);&#10;    static void f2345(const uint8_t* k, const uint8_t* rand, const uint8_t* opc, uint8_t* res, uint8_t* ck, uint8_t* ik, uint8_t* ak);&#10;    static void run(const uint8_t* k, const uint8_t* opc, const uint8_t* rand, const uint8_t* sqn, const uint8_t* amf,&#10;                    uint8_t* res, uint8_t* ck, uint8_t* ik, uint8_t* ak, uint8_t* mac_a);&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/SimEmulator.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/SimEmulator.cpp" />
              <option name="originalContent" value="#include &quot;common.h&quot;&#10;#include &quot;CValues.h&quot;&#10;#include &quot;SimEmulator.h&quot;&#10;#include &quot;Milenage.h&quot;&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;tuple&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;cstring&gt;&#10;&#10;&#10;#include &quot;Aka2G.h&quot;&#10;&#10;&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;SimEmulator::authenticate2G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; ki)&#10;{&#10;    std::vector&lt;uint8_t&gt; sres(4);&#10;    std::vector&lt;uint8_t&gt; kc(8);&#10;    Aka2G::runAka(ki.data(), rand.data(), sres.data(), kc.data());&#10;    return {sres, kc};&#10;}&#10;&#10;&#10;std::tuple&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;,&#10;           std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;SimEmulator::authenticate3G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf)&#10;{&#10;&#10;    if (rand.size() != 16 || autn.size() != 16 ||&#10;        k.size() != 16 || opc.size() != 16 || amf.size() != 2)&#10;        throw std::invalid_argument(&quot;authenticate3G: invalid input sizes&quot;);&#10;&#10;    Block128 RAND, K, OPc, AMF{};&#10;    std::copy(rand.begin(), rand.end(), RAND.begin());&#10;    std::copy(k.begin(), k.end(), K.begin());&#10;    std::copy(opc.begin(), opc.end(), OPc.begin());&#10;    std::copy(amf.begin(), amf.end(), AMF.begin());&#10;&#10;    // Split AUTN fields: SQN ⊕ AK (6), AMF (2), MAC-A (8)&#10;    std::array&lt;uint8_t,6&gt; sqn_xor_ak{};&#10;    std::array&lt;uint8_t,8&gt; mac_a_received{};&#10;    std::memcpy(sqn_xor_ak.data(), autn.data(), 6);&#10;    std::memcpy(mac_a_received.data(), autn.data() + 8, 8);&#10;&#10;    // --- Step 1: Derive RES, CK, IK, AK from RAND ---&#10;    std::array&lt;uint8_t,8&gt; RES{};&#10;    Block128 CK{}, IK{};&#10;    std::array&lt;uint8_t,6&gt; AK{}, AKstar{};&#10;    f2345(K, RAND, OPc, RES, CK, IK, AK, AKstar);&#10;&#10;    // --- Step 2: Recover SQN = (SQN⊕AK)⊕AK ---&#10;    Block128 SQN{};&#10;    for (int i = 0; i &lt; 6; ++i)&#10;        SQN[i] = sqn_xor_ak[i] ^ AK[i];&#10;&#10;    // --- Step 3: Compute expected MAC-A using f1() ---&#10;    std::array&lt;uint8_t,8&gt; MAC_A{}, MAC_S{};&#10;    f1(K, RAND, SQN, AMF, OPc, MAC_A, MAC_S);&#10;&#10;    if (std::memcmp(MAC_A.data(), mac_a_received.data(), 8) != 0)&#10;        throw std::runtime_error(&quot;3G authentication failed: MAC mismatch&quot;);&#10;&#10;    // --- Step 4: Return success with (RES, CK, IK, AK) ---&#10;    return {&#10;        std::vector&lt;uint8_t&gt;(RES.begin(), RES.end()),&#10;        std::vector&lt;uint8_t&gt;(CK.begin(),  CK.end()),&#10;        std::vector&lt;uint8_t&gt;(IK.begin(),  IK.end()),&#10;        std::vector&lt;uint8_t&gt;(AK.begin(),  AK.end())&#10;    };&#10;}&#10;&#10;&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;SimEmulator::authenticate4G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                            const std::string&amp; snn)&#10;{&#10;    // Step 1: Perform 3G AKA&#10;    auto [res, ck, ik, ak] = authenticate3G(rand, autn, k, opc, amf);&#10;&#10;    // Step 2: Build KDF key = CK || IK&#10;    std::vector&lt;uint8_t&gt; kdf_key;&#10;    kdf_key.reserve(32);&#10;    kdf_key.insert(kdf_key.end(), ck.begin(), ck.end());&#10;    kdf_key.insert(kdf_key.end(), ik.begin(), ik.end());&#10;&#10;    // Step 3: Construct input string S for KDF (3GPP TS 33.401 §A.2.1)&#10;    // FC = 0x10 for K_ASME derivation&#10;    std::vector&lt;uint8_t&gt; s;&#10;    s.push_back(0x10);&#10;&#10;    // Parameter 0: SNN&#10;    s.insert(s.end(), snn.begin(), snn.end());&#10;    const uint16_t L0 = static_cast&lt;uint16_t&gt;(snn.size());&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L0 &gt;&gt; 8));&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L0 &amp; 0xFF));&#10;&#10;    // Parameter 1: SQN ⊕ AK (extracted from AUTN)&#10;    std::vector&lt;uint8_t&gt; sqn_xor_ak(autn.begin(), autn.begin() + 6);&#10;    const uint16_t L1 = static_cast&lt;uint16_t&gt;(sqn_xor_ak.size());&#10;    s.insert(s.end(), sqn_xor_ak.begin(), sqn_xor_ak.end());&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L1 &gt;&gt; 8));&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L1 &amp; 0xFF));&#10;&#10;    // Step 4: HMAC-SHA-256 key derivation&#10;    Block256 k_asme{};&#10;    unsigned int k_asme_len = 0;&#10;&#10;    if (!HMAC(EVP_sha256(), kdf_key.data(), static_cast&lt;int&gt;(kdf_key.size()),&#10;              s.data(), s.size(), k_asme.data(), &amp;k_asme_len))&#10;        throw std::runtime_error(&quot;HMAC computation failed&quot;);&#10;&#10;    if (k_asme_len != 32)&#10;        throw std::runtime_error(&quot;K_ASME length mismatch&quot;);&#10;&#10;    // Optional: cleanse sensitive memory&#10;    // OPENSSL_cleanse(kdf_key.data(), kdf_key.size());&#10;&#10;    return {res, k_asme};&#10;}&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;SimEmulator::authenticate5G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                            const std::string&amp; snn)&#10;{&#10;    // Step 1: Perform 3G AKA → RES, CK, IK, AK&#10;    auto [res, ck, ik, ak] = authenticate3G(rand, autn, k, opc, amf);&#10;&#10;    // Base key: CK || IK&#10;    std::vector&lt;uint8_t&gt; ck_ik;&#10;    ck_ik.reserve(32);&#10;    ck_ik.insert(ck_ik.end(), ck.begin(), ck.end());&#10;    ck_ik.insert(ck_ik.end(), ik.begin(), ik.end());&#10;&#10;    // --- Helper lambda to append a 16-bit big-endian length ---&#10;    auto append_len = [](std::vector&lt;uint8_t&gt;&amp; v, size_t len) {&#10;        v.push_back(static_cast&lt;uint8_t&gt;((len &gt;&gt; 8) &amp; 0xFF));&#10;        v.push_back(static_cast&lt;uint8_t&gt;(len &amp; 0xFF));&#10;    };&#10;&#10;    // Extract SQN⊕AK from AUTN (first 6 bytes)&#10;    std::vector&lt;uint8_t&gt; sqn_xor_ak(autn.begin(), autn.begin() + 6);&#10;&#10;    // ──────────────────────────────&#10;    // Step 2 – Derive K_AUSF (Annex A.4)&#10;    // S = FC || SNN || L0 || (SQN⊕AK) || L1&#10;    std::vector&lt;uint8_t&gt; s_kausf;&#10;    s_kausf.push_back(0x6A);  // FC&#10;    s_kausf.insert(s_kausf.end(), snn.begin(), snn.end());&#10;    append_len(s_kausf, snn.size());&#10;    s_kausf.insert(s_kausf.end(), sqn_xor_ak.begin(), sqn_xor_ak.end());&#10;    append_len(s_kausf, sqn_xor_ak.size());&#10;&#10;    Block256 k_ausf{};&#10;    unsigned int k_ausf_len = 0;&#10;    if (!HMAC(EVP_sha256(), ck_ik.data(), static_cast&lt;int&gt;(ck_ik.size()),&#10;              s_kausf.data(), s_kausf.size(), k_ausf.data(), &amp;k_ausf_len) ||&#10;        k_ausf_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive K_AUSF&quot;);&#10;&#10;    // ──────────────────────────────&#10;    // Step 3 – Derive K_SEAF (Annex A.5)&#10;    // S = FC || SNN || L0&#10;    std::vector&lt;uint8_t&gt; s_kseaf;&#10;    s_kseaf.push_back(0x6B);&#10;    s_kseaf.insert(s_kseaf.end(), snn.begin(), snn.end());&#10;    append_len(s_kseaf, snn.size());&#10;&#10;    Block256 k_seaf{};&#10;    unsigned int k_seaf_len = 0;&#10;    if (!HMAC(EVP_sha256(), k_ausf.data(), static_cast&lt;int&gt;(k_ausf.size()),&#10;              s_kseaf.data(), s_kseaf.size(), k_seaf.data(), &amp;k_seaf_len) ||&#10;        k_seaf_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive K_SEAF&quot;);&#10;&#10;    // ──────────────────────────────&#10;    // Step 4 – Derive RES* (Annex A.6)&#10;    // S = FC || SNN || L0 || RAND || L1 || RES || L2&#10;    std::vector&lt;uint8_t&gt; s_res_star;&#10;    s_res_star.push_back(0x6D);&#10;    s_res_star.insert(s_res_star.end(), snn.begin(), snn.end());&#10;    append_len(s_res_star, snn.size());&#10;    s_res_star.insert(s_res_star.end(), rand.begin(), rand.end());&#10;    append_len(s_res_star, rand.size());&#10;    s_res_star.insert(s_res_star.end(), res.begin(), res.end());&#10;    append_len(s_res_star, res.size());&#10;&#10;    std::array&lt;uint8_t, 32&gt; res_star_full{};&#10;    unsigned int res_star_len = 0;&#10;    if (!HMAC(EVP_sha256(), ck_ik.data(), static_cast&lt;int&gt;(ck_ik.size()),&#10;              s_res_star.data(), s_res_star.size(),&#10;              res_star_full.data(), &amp;res_star_len) ||&#10;        res_star_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive RES*&quot;);&#10;&#10;    // Rightmost 16 bytes = RES*&#10;    std::vector&lt;uint8_t&gt; res_star(res_star_full.end() - 16, res_star_full.end());&#10;&#10;    return {res_star, k_seaf};&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;common.h&quot;&#10;#include &quot;CValues.h&quot;&#10;#include &quot;SimEmulator.h&quot;&#10;#include &quot;Milenage.h&quot;&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;tuple&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;cstring&gt;&#10;&#10;&#10;#include &quot;Aka2G.h&quot;&#10;&#10;&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;SimEmulator::authenticate2G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; ki)&#10;{&#10;    std::vector&lt;uint8_t&gt; sres(4);&#10;    std::vector&lt;uint8_t&gt; kc(8);&#10;    Aka2G::runAka(ki.data(), rand.data(), sres.data(), kc.data());&#10;    return {sres, kc};&#10;}&#10;&#10;&#10;std::tuple&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;,&#10;           std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;SimEmulator::authenticate3G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf)&#10;{&#10;&#10;    if (rand.size() != 16 || autn.size() != 16 ||&#10;        k.size() != 16 || opc.size() != 16 || amf.size() != 2)&#10;        throw std::invalid_argument(&quot;authenticate3G: invalid input sizes&quot;);&#10;&#10;    Block128 RAND, K, OPc, AMF{};&#10;    std::copy(rand.begin(), rand.end(), RAND.begin());&#10;    std::copy(k.begin(), k.end(), K.begin());&#10;    std::copy(opc.begin(), opc.end(), OPc.begin());&#10;    std::copy(amf.begin(), amf.end(), AMF.begin());&#10;&#10;    // Split AUTN fields: SQN ⊕ AK (6), AMF (2), MAC-A (8)&#10;    std::array&lt;uint8_t,6&gt; sqn_xor_ak{};&#10;    std::array&lt;uint8_t,8&gt; mac_a_received{};&#10;    std::memcpy(sqn_xor_ak.data(), autn.data(), 6);&#10;    std::memcpy(mac_a_received.data(), autn.data() + 8, 8);&#10;&#10;    // --- Step 1: Derive RES, CK, IK, AK from RAND ---&#10;    std::array&lt;uint8_t,8&gt; RES{};&#10;    Block128 CK{}, IK{};&#10;    std::array&lt;uint8_t,6&gt; AK{}, AKstar{};&#10;    f2345(K, RAND, OPc, RES, CK, IK, AK, AKstar);&#10;&#10;    // --- Step 2: Recover SQN = (SQN⊕AK)⊕AK ---&#10;    Block128 SQN{};&#10;    for (int i = 0; i &lt; 6; ++i)&#10;        SQN[i] = sqn_xor_ak[i] ^ AK[i];&#10;&#10;    // --- Step 3: Compute expected MAC-A using f1() ---&#10;    std::array&lt;uint8_t,8&gt; MAC_A{}, MAC_S{};&#10;    f1(K, RAND, SQN, AMF, OPc, MAC_A, MAC_S);&#10;&#10;    if (std::memcmp(MAC_A.data(), mac_a_received.data(), 8) != 0)&#10;        throw std::runtime_error(&quot;3G authentication failed: MAC mismatch&quot;);&#10;&#10;    // --- Step 4: Return success with (RES, CK, IK, AK) ---&#10;    return {&#10;        std::vector&lt;uint8_t&gt;(RES.begin(), RES.end()),&#10;        std::vector&lt;uint8_t&gt;(CK.begin(),  CK.end()),&#10;        std::vector&lt;uint8_t&gt;(IK.begin(),  IK.end()),&#10;        std::vector&lt;uint8_t&gt;(AK.begin(),  AK.end())&#10;    };&#10;}&#10;&#10;&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;SimEmulator::authenticate4G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                            const std::string&amp; snn)&#10;{&#10;    // Step 1: Perform 3G AKA&#10;    auto [res, ck, ik, ak] = authenticate3G(rand, autn, k, opc, amf);&#10;&#10;    // Step 2: Build KDF key = CK || IK&#10;    std::vector&lt;uint8_t&gt; kdf_key;&#10;    kdf_key.reserve(32);&#10;    kdf_key.insert(kdf_key.end(), ck.begin(), ck.end());&#10;    kdf_key.insert(kdf_key.end(), ik.begin(), ik.end());&#10;&#10;    // Step 3: Construct input string S for KDF (3GPP TS 33.401 §A.2.1)&#10;    // FC = 0x10 for K_ASME derivation&#10;    std::vector&lt;uint8_t&gt; s;&#10;    s.push_back(0x10);&#10;&#10;    // Parameter 0: SNN&#10;    s.insert(s.end(), snn.begin(), snn.end());&#10;    const uint16_t L0 = static_cast&lt;uint16_t&gt;(snn.size());&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L0 &gt;&gt; 8));&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L0 &amp; 0xFF));&#10;&#10;    // Parameter 1: SQN ⊕ AK (extracted from AUTN)&#10;    std::vector&lt;uint8_t&gt; sqn_xor_ak(autn.begin(), autn.begin() + 6);&#10;    const uint16_t L1 = static_cast&lt;uint16_t&gt;(sqn_xor_ak.size());&#10;    s.insert(s.end(), sqn_xor_ak.begin(), sqn_xor_ak.end());&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L1 &gt;&gt; 8));&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L1 &amp; 0xFF));&#10;&#10;    // Step 4: HMAC-SHA-256 key derivation&#10;    Block256 k_asme{};&#10;    unsigned int k_asme_len = 0;&#10;&#10;    if (!HMAC(EVP_sha256(), kdf_key.data(), static_cast&lt;int&gt;(kdf_key.size()),&#10;              s.data(), s.size(), k_asme.data(), &amp;k_asme_len))&#10;        throw std::runtime_error(&quot;HMAC computation failed&quot;);&#10;&#10;    if (k_asme_len != 32)&#10;        throw std::runtime_error(&quot;K_ASME length mismatch&quot;);&#10;&#10;    // Optional: cleanse sensitive memory&#10;    // OPENSSL_cleanse(kdf_key.data(), kdf_key.size());&#10;&#10;    return {res, k_asme};&#10;}&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;SimEmulator::authenticate5G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                            const std::string&amp; snn)&#10;{&#10;    // Step 1: Perform 3G AKA → RES, CK, IK, AK&#10;    auto [res, ck, ik, ak] = authenticate3G(rand, autn, k, opc, amf);&#10;&#10;    // Base key: CK || IK&#10;    std::vector&lt;uint8_t&gt; ck_ik;&#10;    ck_ik.reserve(32);&#10;    ck_ik.insert(ck_ik.end(), ck.begin(), ck.end());&#10;    ck_ik.insert(ck_ik.end(), ik.begin(), ik.end());&#10;&#10;    // --- Helper lambda to append a 16-bit big-endian length ---&#10;    auto append_len = [](std::vector&lt;uint8_t&gt;&amp; v, size_t len) {&#10;        v.push_back(static_cast&lt;uint8_t&gt;((len &gt;&gt; 8) &amp; 0xFF));&#10;        v.push_back(static_cast&lt;uint8_t&gt;(len &amp; 0xFF));&#10;    };&#10;&#10;    // Extract SQN⊕AK from AUTN (first 6 bytes)&#10;    std::vector&lt;uint8_t&gt; sqn_xor_ak(autn.begin(), autn.begin() + 6);&#10;&#10;    // ──────────────────────────────&#10;    // Step 2 – Derive K_AUSF (Annex A.4)&#10;    // S = FC || SNN || L0 || (SQN⊕AK) || L1&#10;    std::vector&lt;uint8_t&gt; s_kausf;&#10;    s_kausf.push_back(0x6A);  // FC&#10;    s_kausf.insert(s_kausf.end(), snn.begin(), snn.end());&#10;    append_len(s_kausf, snn.size());&#10;    s_kausf.insert(s_kausf.end(), sqn_xor_ak.begin(), sqn_xor_ak.end());&#10;    append_len(s_kausf, sqn_xor_ak.size());&#10;&#10;    Block256 k_ausf{};&#10;    unsigned int k_ausf_len = 0;&#10;    if (!HMAC(EVP_sha256(), ck_ik.data(), static_cast&lt;int&gt;(ck_ik.size()),&#10;              s_kausf.data(), s_kausf.size(), k_ausf.data(), &amp;k_ausf_len) ||&#10;        k_ausf_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive K_AUSF&quot;);&#10;&#10;    // ──────────────────────────────&#10;    // Step 3 – Derive K_SEAF (Annex A.5)&#10;    // S = FC || SNN || L0&#10;    std::vector&lt;uint8_t&gt; s_kseaf;&#10;    s_kseaf.push_back(0x6B);&#10;    s_kseaf.insert(s_kseaf.end(), snn.begin(), snn.end());&#10;    append_len(s_kseaf, snn.size());&#10;&#10;    Block256 k_seaf{};&#10;    unsigned int k_seaf_len = 0;&#10;    if (!HMAC(EVP_sha256(), k_ausf.data(), static_cast&lt;int&gt;(k_ausf.size()),&#10;              s_kseaf.data(), s_kseaf.size(), k_seaf.data(), &amp;k_seaf_len) ||&#10;        k_seaf_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive K_SEAF&quot;);&#10;&#10;    // ──────────────────────────────&#10;    // Step 4 – Derive RES* (Annex A.6)&#10;    // S = FC || SNN || L0 || RAND || L1 || RES || L2&#10;    std::vector&lt;uint8_t&gt; s_res_star;&#10;    s_res_star.push_back(0x6D);&#10;    s_res_star.insert(s_res_star.end(), snn.begin(), snn.end());&#10;    append_len(s_res_star, snn.size());&#10;    s_res_star.insert(s_res_star.end(), rand.begin(), rand.end());&#10;    append_len(s_res_star, rand.size());&#10;    s_res_star.insert(s_res_star.end(), res.begin(), res.end());&#10;    append_len(s_res_star, res.size());&#10;&#10;    std::array&lt;uint8_t, 32&gt; res_star_full{};&#10;    unsigned int res_star_len = 0;&#10;    if (!HMAC(EVP_sha256(), ck_ik.data(), static_cast&lt;int&gt;(ck_ik.size()),&#10;              s_res_star.data(), s_res_star.size(),&#10;              res_star_full.data(), &amp;res_star_len) ||&#10;        res_star_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive RES*&quot;);&#10;&#10;    // Rightmost 16 bytes = RES*&#10;    std::vector&lt;uint8_t&gt; res_star(res_star_full.end() - 16, res_star_full.end());&#10;&#10;    return {res_star, k_seaf};&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/SimEmulator.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/SimEmulator.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;&#10;#include &quot;Milenage.h&quot;&#10;&#10;class SimEmulator {&#10;public:&#10;    /**&#10;     * @brief Performs 2G (GSM) authentication using the COMP128-1 algorithm.&#10;     *&#10;     * This function simulates the authentication process of a 2G SIM card. It takes a random&#10;     * challenge (RAND) from the network and the secret key (Ki) from the SIM, and computes&#10;     * the Signed Response (SRES) and the Ciphering Key (Kc).&#10;     *&#10;     * @param rand A 16-byte (128-bit) random challenge from the network.&#10;     * @param ki A 16-byte (128-bit) secret key stored on the SIM card.&#10;     * @return A pair containing the 4-byte SRES and the 8-byte Kc.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;    authenticate2G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; ki);&#10;&#10;    /**&#10;     * @brief Performs 3G (UMTS) authentication using the Milenage algorithm.&#10;     *&#10;     * This function simulates the 3G authentication and key agreement (AKA) procedure. It takes&#10;     * a random challenge (RAND), an Authentication Token (AUTN), the secret key (K), the Operator&#10;     * Variant Algorithm Configuration Field (OPc), and the Authentication Management Field (AMF).&#10;     * It verifies the AUTN and, if successful, computes the Response (RES), Cipher Key (CK),&#10;     * Integrity Key (IK), and Anonymity Key (AK).&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @return A tuple containing the RES, CK, IK, and AK.&#10;     */&#10;    static std::tuple&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;    authenticate3G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf);&#10;&#10;    /**&#10;     * @brief Performs 4G (LTE) Evolved Packet System (EPS) authentication (EPS-AKA).&#10;     *&#10;     * This function builds on 3G AKA to perform 4G authentication. It takes the same parameters&#10;     * as 3G AKA, plus the Serving Network Name (SNN). It first runs the 3G authentication&#10;     * process to generate RES, CK, and IK. It then uses CK and IK to derive the K_ASME&#10;     * (Key for Access Security Management Entity) as specified in 3GPP TS 33.401.&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @param snn The Serving Network Name, used in the key derivation process.&#10;     * @return A pair containing the 8-byte RES and the 32-byte K_ASME.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;    authenticate4G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                   const std::string&amp; snn);&#10;&#10;    /**&#10;     * @brief Performs 5G authentication and key agreement (5G-AKA).&#10;     *&#10;     * This function simulates the 5G AKA procedure as specified in 3GPP TS 33.501. It starts&#10;     * by performing a 3G AKA authentication to obtain RES, CK, and IK. It then uses these&#10;     * keys and the Serving Network Name (SNN) to derive the 5G keys: K_AUSF (Key for the&#10;     * Authentication Server Function) and K_SEAF (Key for the Security Anchor Function).&#10;     * Finally, it computes the 5G response, RES*.&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @param snn The Serving Network Name, used in the key derivation process.&#10;     * @return A pair containing the 16-byte RES* and the 32-byte K_SEAF.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;    authenticate5G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                   const std::string&amp; snn);&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;&#10;&#10;#include &quot;Milenage.h&quot;&#10;&#10;class SimEmulator {&#10;public:&#10;    /**&#10;     * @brief Performs 2G (GSM) authentication using the COMP128-1 algorithm.&#10;     *&#10;     * This function simulates the authentication process of a 2G SIM card. It takes a random&#10;     * challenge (RAND) from the network and the secret key (Ki) from the SIM, and computes&#10;     * the Signed Response (SRES) and the Ciphering Key (Kc).&#10;     *&#10;     * @param rand A 16-byte (128-bit) random challenge from the network.&#10;     * @param ki A 16-byte (128-bit) secret key stored on the SIM card.&#10;     * @return A pair containing the 4-byte SRES and the 8-byte Kc.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;    authenticate2G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; ki);&#10;&#10;    /**&#10;     * @brief Derives a 256-bit seed from 2G authentication outputs.&#10;     *&#10;     * This function performs a 2G authentication and then securely hashes the resulting&#10;     * SRES and Kc values using SHA-256 to produce a 256-bit seed.&#10;     *&#10;     * @param rand A 16-byte (128-bit) random challenge from the network.&#10;     * @param ki A 16-byte (128-bit) secret key stored on the SIM card.&#10;     * @return A 256-bit (32-byte) seed as a std::array.&#10;     */&#10;    static Block256 deriveSeed2G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; ki);&#10;&#10;    /**&#10;     * @brief Performs 3G (UMTS) authentication using the Milenage algorithm.&#10;     *&#10;     * This function simulates the 3G authentication and key agreement (AKA) procedure. It takes&#10;     * a random challenge (RAND), an Authentication Token (AUTN), the secret key (K), the Operator&#10;     * Variant Algorithm Configuration Field (OPc), and the Authentication Management Field (AMF).&#10;     * It verifies the AUTN and, if successful, computes the Response (RES), Cipher Key (CK),&#10;     * Integrity Key (IK), and Anonymity Key (AK).&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @return A tuple containing the RES, CK, IK, and AK.&#10;     */&#10;    static std::tuple&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;    authenticate3G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf);&#10;&#10;    /**&#10;     * @brief Performs 4G (LTE) Evolved Packet System (EPS) authentication (EPS-AKA).&#10;     *&#10;     * This function builds on 3G AKA to perform 4G authentication. It takes the same parameters&#10;     * as 3G AKA, plus the Serving Network Name (SNN). It first runs the 3G authentication&#10;     * process to generate RES, CK, and IK. It then uses CK and IK to derive the K_ASME&#10;     * (Key for Access Security Management Entity) as specified in 3GPP TS 33.401.&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @param snn The Serving Network Name, used in the key derivation process.&#10;     * @return A pair containing the 8-byte RES and the 32-byte K_ASME.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;    authenticate4G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                   const std::string&amp; snn);&#10;&#10;    /**&#10;     * @brief Performs 5G authentication and key agreement (5G-AKA).&#10;     *&#10;     * This function simulates the 5G AKA procedure as specified in 3GPP TS 33.501. It starts&#10;     * by performing a 3G AKA authentication to obtain RES, CK, and IK. It then uses these&#10;     * keys and the Serving Network Name (SNN) to derive the 5G keys: K_AUSF (Key for the&#10;     * Authentication Server Function) and K_SEAF (Key for the Security Anchor Function).&#10;     * Finally, it computes the 5G response, RES*.&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @param snn The Serving Network Name, used in the key derivation process.&#10;     * @return A pair containing the 16-byte RES* and the 32-byte K_SEAF.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;    authenticate5G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                   const std::string&amp; snn);&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Wallet.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Wallet.cpp" />
              <option name="originalContent" value="#include &quot;Wallet.h&quot;&#10;#include &quot;common.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &lt;cstring&gt; // For strlen&#10;&#10;// Helper: print bytes as hex&#10;static void print_hex(const std::string&amp; label, const std::vector&lt;uint8_t&gt;&amp; data) {&#10;    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; label &lt;&lt; &quot;: &quot;;&#10;    for (auto b : data) std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)b;&#10;    std::cout &lt;&lt; std::dec &lt;&lt; std::endl;&#10;}&#10;&#10;static std::pair&lt;Block256, Block256&gt; bip32_master_key(const Block256&amp; seed) {&#10;    static constexpr char key[] = &quot;Bitcoin seed&quot;;&#10;    unsigned int outlen = 64;&#10;    std::array&lt;uint8_t, 64&gt; out{};&#10;&#10;    unsigned char* result = HMAC(&#10;        EVP_sha512(),&#10;        key, sizeof(key) - 1,&#10;        seed.data(), seed.size(),&#10;        out.data(), &amp;outlen&#10;    );&#10;&#10;    if (!result || outlen != 64) {&#10;        throw std::runtime_error(&quot;HMAC-SHA512 failed&quot;);&#10;    }&#10;&#10;    Block256 privkey, chaincode;&#10;    std::memcpy(privkey.data(), out.data(), 32);&#10;    std::memcpy(chaincode.data(), out.data() + 32, 32);&#10;&#10;    if (!is_valid_secp256k1_key(privkey)) {&#10;        throw std::runtime_error(&quot;Invalid master private key (IL out of range)&quot;);&#10;    }&#10;&#10;    return {privkey, chaincode};&#10;}&#10;&#10;&#10;std::pair&lt;Block256, Block256&gt; Wallet::deriveMaster(const Block256&amp; seed) {&#10;    return bip32_master_key(seed);&#10;}" />
              <option name="updatedContent" value="#include &quot;Wallet.h&quot;&#10;#include &quot;common.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &lt;cstring&gt; // For strlen&#10;#include &lt;algorithm&gt; // For std::all_of&#10;&#10;// Helper: print bytes as hex&#10;static void print_hex(const std::string&amp; label, const std::vector&lt;uint8_t&gt;&amp; data) {&#10;    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; label &lt;&lt; &quot;: &quot;;&#10;    for (auto b : data) std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)b;&#10;    std::cout &lt;&lt; std::dec &lt;&lt; std::endl;&#10;}&#10;&#10;// The order of the secp256k1 curve&#10;static const Block256 SECP256K1_ORDER = {&#10;    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,&#10;    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,&#10;    0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,&#10;    0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41&#10;};&#10;&#10;// A private key is valid if it is not 0 and is less than the curve order n.&#10;static bool is_valid_secp256k1_key(const Block256&amp; privkey) {&#10;    bool is_zero = std::all_of(privkey.begin(), privkey.end(), [](uint8_t b) { return b == 0; });&#10;    if (is_zero) {&#10;        return false;&#10;    }&#10;&#10;    // memcmp returns &lt; 0 if first arg is less than second&#10;    return std::memcmp(privkey.data(), SECP256K1_ORDER.data(), 32) &lt; 0;&#10;}&#10;&#10;static std::pair&lt;Block256, Block256&gt; bip32_master_key(const Block256&amp; seed) {&#10;    static constexpr char key[] = &quot;Bitcoin seed&quot;;&#10;    unsigned int outlen = 64;&#10;    std::array&lt;uint8_t, 64&gt; out{};&#10;&#10;    unsigned char* result = HMAC(&#10;        EVP_sha512(),&#10;        key, sizeof(key) - 1,&#10;        seed.data(), seed.size(),&#10;        out.data(), &amp;outlen&#10;    );&#10;&#10;    if (!result || outlen != 64) {&#10;        throw std::runtime_error(&quot;HMAC-SHA512 failed&quot;);&#10;    }&#10;&#10;    Block256 privkey, chaincode;&#10;    std::memcpy(privkey.data(), out.data(), 32);&#10;    std::memcpy(chaincode.data(), out.data() + 32, 32);&#10;&#10;    if (!is_valid_secp256k1_key(privkey)) {&#10;        throw std::runtime_error(&quot;Invalid master private key (IL out of range)&quot;);&#10;    }&#10;&#10;    return {privkey, chaincode};&#10;}&#10;&#10;&#10;std::pair&lt;Block256, Block256&gt; Wallet::deriveMaster(const Block256&amp; seed) {&#10;    return bip32_master_key(seed);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Wallet.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Wallet.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;&#10;class Wallet {&#10;public:&#10;    /**&#10;     * @brief Derives the master key from a given seed using BIP39.&#10;     *&#10;     * This function takes a seed (typically derived from a mnemonic phrase) and&#10;     * uses it to generate a master private key for a hierarchical deterministic (HD)&#10;     * wallet, following the BIP39 standard. The resulting master key can then be&#10;     * used to derive child keys.&#10;     *&#10;     * @param seed A vector of bytes representing the seed. The seed should be&#10;     *             between 128 and 512 bits (16 to 64 bytes).&#10;     * @return A pair containing the 32-byte master private key and the 32-byte chain code.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt; deriveMaster(const std::vector&lt;uint8_t&gt;&amp; seed);&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &quot;common.h&quot;&#10;&#10;class Wallet {&#10;public:&#10;    /**&#10;     * @brief Derives the master key from a given seed using BIP32.&#10;     *&#10;     * This function takes a 256-bit (32-byte) seed and uses it to generate a&#10;     * master private key and chain code for a hierarchical deterministic (HD)&#10;     * wallet, following the BIP32 standard.&#10;     *&#10;     * @param seed A 256-bit (32-byte) seed.&#10;     * @return A pair containing the 32-byte master private key and the 32-byte chain code.&#10;     */&#10;    static std::pair&lt;Block256, Block256&gt; deriveMaster(const Block256&amp; seed);&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/common.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/common.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;array&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;cstdint&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;string&gt;&#10;#include &lt;utility&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/kdf.h&gt;&#10;&#10;using Block128 = std::array&lt;uint8_t, 16&gt;;&#10;using Block256 = std::array&lt;uint8_t, 32&gt;;&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;array&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;cstdint&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;string&gt;&#10;#include &lt;utility&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/kdf.h&gt;&#10;&#10;using Block128 = std::array&lt;uint8_t, 16&gt;;&#10;using Block256 = std::array&lt;uint8_t, 32&gt;;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/comp128_table.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/comp128_table.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;cstdint&gt;&#10;&#10;// COMP128-1 substitution table (from public GSM reverse engineering)&#10;extern const uint8_t comp_128_tab[512];&#10;&#10;" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;cstdint&gt;&#10;&#10;class Comp128Table {&#10;public:&#10;    static const uint8_t table[512];&#10;    // Optionally, add static helper methods here if needed&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.cpp" />
              <option name="originalContent" value="#include &quot;Sim.h&quot;&#10;#include &quot;kdf.h&quot;&#10;#include &quot;Wallet.h&quot;&#10;#include &lt;nlohmann/json.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;&#10;int main() {&#10;    SIM sim;&#10;    if (!sim.connect()) {&#10;        std::cerr &lt;&lt; &quot;Failed to connect to SIM.\n&quot;;&#10;        return 1;&#10;    }&#10;&#10;    auto aka = sim.authenticate({0x00, 0x11, 0x22, 0x33}, {0x44, 0x55});&#10;    if (!aka) {&#10;        std::cerr &lt;&lt; &quot;AUTHENTICATE failed.\n&quot;;&#10;        return 1;&#10;    }&#10;&#10;    // Z = CK || IK&#10;    std::vector&lt;uint8_t&gt; Z = aka-&gt;ck;&#10;    Z.insert(Z.end(), aka-&gt;ik.begin(), aka-&gt;ik.end());&#10;&#10;    std::vector&lt;uint8_t&gt; salt = {0x00};&#10;    auto prk = hkdf_extract(salt, Z);&#10;    auto seed = hkdf_expand(prk, &quot;SMILE|AKA-&gt;BIP|seed|v1&quot;, 64);&#10;&#10;    Wallet::deriveMaster(seed);&#10;    sim.disconnect();&#10;&#10;    nlohmann::json j;&#10;    j[&quot;status&quot;] = &quot;ok&quot;;&#10;    j[&quot;seed_hex&quot;] = nlohmann::json::binary(seed);&#10;    std::cout &lt;&lt; j.dump(2) &lt;&lt; &quot;\n&quot;;&#10;&#10;    return 0;&#10;}" />
              <option name="updatedContent" value="#include &quot;Sim.h&quot;&#10;#include &quot;kdf.h&quot;&#10;#include &quot;Wallet.h&quot;&#10;#include &lt;nlohmann/json.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;&#10;int main() {&#10;    SIM sim;&#10;    if (!sim.connect()) {&#10;        std::cerr &lt;&lt; &quot;Failed to connect to SIM.\n&quot;;&#10;        return 1;&#10;    }&#10;&#10;    auto aka = sim.authenticate({0x00, 0x11, 0x22, 0x33}, {0x44, 0x55});&#10;    if (!aka) {&#10;        std::cerr &lt;&lt; &quot;AUTHENTICATE failed.\n&quot;;&#10;        return 1;&#10;    }&#10;&#10;    // Z = CK || IK&#10;    std::vector&lt;uint8_t&gt; Z = aka-&gt;ck;&#10;    Z.insert(Z.end(), aka-&gt;ik.begin(), aka-&gt;ik.end());&#10;&#10;    std::vector&lt;uint8_t&gt; salt = {0x00};&#10;    auto prk = hkdf_extract(salt, Z);&#10;    auto seed_vec = hkdf_expand(prk, &quot;SMILE|AKA-&gt;BIP|seed|v1&quot;, 32);&#10;&#10;    Block256 seed;&#10;    std::copy(seed_vec.begin(), seed_vec.end(), seed.begin());&#10;&#10;    Wallet::deriveMaster(seed);&#10;    sim.disconnect();&#10;&#10;    nlohmann::json j;&#10;    j[&quot;status&quot;] = &quot;ok&quot;;&#10;    j[&quot;seed_hex&quot;] = nlohmann::json::binary(seed_vec);&#10;    std::cout &lt;&lt; j.dump(2) &lt;&lt; &quot;\n&quot;;&#10;&#10;    return 0;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/smile_kdf.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/smile_kdf.cpp" />
              <option name="originalContent" value="#include &quot;smile_kdf.h&quot;&#10;#include &lt;openssl/kdf.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;stdexcept&gt;&#10;&#10;std::vector&lt;uint8_t&gt; smile_hkdf_extract(const std::vector&lt;uint8_t&gt;&amp; salt,&#10;                                        const std::vector&lt;uint8_t&gt;&amp; ikm) {&#10;    EVP_PKEY_CTX* pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr);&#10;    if (!pctx) throw std::runtime_error(&quot;EVP_PKEY_CTX_new_id failed&quot;);&#10;&#10;    std::vector&lt;uint8_t&gt; prk(32);&#10;    if (EVP_PKEY_derive_init(pctx) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set_hkdf_md(pctx, EVP_sha256()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_salt(pctx, salt.data(), salt.size()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_key(pctx, ikm.data(), ikm.size()) &lt;= 0 ||&#10;        EVP_PKEY_derive(pctx, prk.data(), &amp;((size_t){prk.size()})) &lt;= 0) {&#10;        EVP_PKEY_CTX_free(pctx);&#10;        throw std::runtime_error(&quot;HKDF-Extract failed&quot;);&#10;        }&#10;&#10;    EVP_PKEY_CTX_free(pctx);&#10;    return prk;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; smile_hkdf_expand(const std::vector&lt;uint8_t&gt;&amp; prk,&#10;                                       const std::string&amp; info,&#10;                                       size_t L) {&#10;    EVP_PKEY_CTX* pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr);&#10;    if (!pctx) throw std::runtime_error(&quot;EVP_PKEY_CTX_new_id failed&quot;);&#10;&#10;    std::vector&lt;uint8_t&gt; out(L);&#10;    if (EVP_PKEY_derive_init(pctx) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set_hkdf_md(pctx, EVP_sha256()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_key(pctx, prk.data(), prk.size()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_add1_hkdf_info(pctx, reinterpret_cast&lt;const unsigned char*&gt;(info.data()), info.size()) &lt;= 0 ||&#10;        EVP_PKEY_derive(pctx, out.data(), &amp;L) &lt;= 0) {&#10;        EVP_PKEY_CTX_free(pctx);&#10;        throw std::runtime_error(&quot;HKDF-Expand failed&quot;);&#10;        }&#10;&#10;    EVP_PKEY_CTX_free(pctx);&#10;    return out;&#10;}" />
              <option name="updatedContent" value="#include &quot;smile_kdf.h&quot;&#10;#include &lt;openssl/kdf.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;stdexcept&gt;&#10;&#10;std::vector&lt;uint8_t&gt; smile_hkdf_extract(const std::vector&lt;uint8_t&gt;&amp; salt,&#10;                                        const std::vector&lt;uint8_t&gt;&amp; ikm) {&#10;    EVP_PKEY_CTX* pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr);&#10;    if (!pctx) throw std::runtime_error(&quot;EVP_PKEY_CTX_new_id failed&quot;);&#10;&#10;    std::vector&lt;uint8_t&gt; prk(32);&#10;    size_t prk_len = prk.size();&#10;    if (EVP_PKEY_derive_init(pctx) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set_hkdf_md(pctx, EVP_sha256()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_salt(pctx, salt.data(), salt.size()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_key(pctx, ikm.data(), ikm.size()) &lt;= 0 ||&#10;        EVP_PKEY_derive(pctx, prk.data(), &amp;prk_len) &lt;= 0) {&#10;        EVP_PKEY_CTX_free(pctx);&#10;        throw std::runtime_error(&quot;HKDF-Extract failed&quot;);&#10;        }&#10;&#10;    EVP_PKEY_CTX_free(pctx);&#10;    return prk;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; smile_hkdf_expand(const std::vector&lt;uint8_t&gt;&amp; prk,&#10;                                       const std::string&amp; info,&#10;                                       size_t L) {&#10;    EVP_PKEY_CTX* pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr);&#10;    if (!pctx) throw std::runtime_error(&quot;EVP_PKEY_CTX_new_id failed&quot;);&#10;&#10;    std::vector&lt;uint8_t&gt; out(L);&#10;    if (EVP_PKEY_derive_init(pctx) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set_hkdf_md(pctx, EVP_sha256()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_key(pctx, prk.data(), prk.size()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_add1_hkdf_info(pctx, reinterpret_cast&lt;const unsigned char*&gt;(info.data()), info.size()) &lt;= 0 ||&#10;        EVP_PKEY_derive(pctx, out.data(), &amp;L) &lt;= 0) {&#10;        EVP_PKEY_CTX_free(pctx);&#10;        throw std::runtime_error(&quot;HKDF-Expand failed&quot;);&#10;        }&#10;&#10;    EVP_PKEY_CTX_free(pctx);&#10;    return out;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/smile_wallet.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/smile_wallet.cpp" />
              <option name="originalContent" value="#include &quot;smile_wallet.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;&#10;// Helper: print bytes as hex&#10;static void print_hex(const std::string&amp; label, const std::vector&lt;uint8_t&gt;&amp; data) {&#10;    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; label &lt;&lt; &quot;: &quot;;&#10;    for (auto b : data) std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)b;&#10;    std::cout &lt;&lt; std::dec &lt;&lt; std::endl;&#10;}&#10;&#10;// Implements BIP-32 master key derivation (returns privkey + chaincode)&#10;static std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt; bip32_master_key(const std::vector&lt;uint8_t&gt;&amp; seed) {&#10;    const char* key = &quot;Bitcoin seed&quot;;&#10;    unsigned int outlen = 64;&#10;    std::vector&lt;uint8_t&gt; out(64);&#10;    HMAC(EVP_sha512(), key, strlen(key), seed.data(), seed.size(), out.data(), &amp;outlen);&#10;    std::vector&lt;uint8_t&gt; privkey(out.begin(), out.begin() + 32);&#10;    std::vector&lt;uint8_t&gt; chaincode(out.begin() + 32, out.end());&#10;    return {privkey, chaincode};&#10;}&#10;&#10;void SmileWallet::derive_master(const std::vector&lt;uint8_t&gt;&amp; seed) {&#10;    auto [privkey, chaincode] = bip32_master_key(seed);&#10;    std::cout &lt;&lt; &quot;[SMILE] Derived master key (BIP-32):\n&quot;;&#10;    print_hex(&quot;privkey&quot;, privkey);&#10;    print_hex(&quot;chaincode&quot;, chaincode);&#10;}" />
              <option name="updatedContent" value="#include &quot;smile_wallet.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &lt;cstring&gt; // For strlen&#10;&#10;// Helper: print bytes as hex&#10;static void print_hex(const std::string&amp; label, const std::vector&lt;uint8_t&gt;&amp; data) {&#10;    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; label &lt;&lt; &quot;: &quot;;&#10;    for (auto b : data) std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)b;&#10;    std::cout &lt;&lt; std::dec &lt;&lt; std::endl;&#10;}&#10;&#10;// Implements BIP-32 master key derivation (returns privkey + chaincode)&#10;static std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt; bip32_master_key(const std::vector&lt;uint8_t&gt;&amp; seed) {&#10;    const char* key = &quot;Bitcoin seed&quot;;&#10;    unsigned int outlen = 64;&#10;    std::vector&lt;uint8_t&gt; out(64);&#10;    HMAC(EVP_sha512(), key, strlen(key), seed.data(), seed.size(), out.data(), &amp;outlen);&#10;    std::vector&lt;uint8_t&gt; privkey(out.begin(), out.begin() + 32);&#10;    std::vector&lt;uint8_t&gt; chaincode(out.begin() + 32, out.end());&#10;    return {privkey, chaincode};&#10;}&#10;&#10;void SmileWallet::derive_master(const std::vector&lt;uint8_t&gt;&amp; seed) {&#10;    auto [privkey, chaincode] = bip32_master_key(seed);&#10;    std::cout &lt;&lt; &quot;[SMILE] Derived master key (BIP-32):\n&quot;;&#10;    print_hex(&quot;privkey&quot;, privkey);&#10;    print_hex(&quot;chaincode&quot;, chaincode);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.20)&#10;project(smile LANGUAGES C CXX)&#10;&#10;set(CMAKE_TOOLCHAIN_FILE&#10;        &quot;${CMAKE_CURRENT_SOURCE_DIR}/external/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;&#10;        CACHE STRING &quot;Vcpkg toolchain file&quot;)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_EXPORT_COMPILE_COMMANDS ON)&#10;&#10;# Integrate vcpkg&#10;if(DEFINED ENV{VCPKG_ROOT})&#10;    set(CMAKE_TOOLCHAIN_FILE &quot;$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake&quot;&#10;            CACHE STRING &quot;&quot;)&#10;endif()&#10;&#10;find_package(OpenSSL REQUIRED)&#10;find_package(nlohmann_json REQUIRED)&#10;&#10;&#10;add_executable(smile&#10;        # Add all .cpp files in src directory&#10;        $&lt;TARGET_FILE_DIR:smile&gt;/../src/*.cpp&#10;)&#10;&#10;target_include_directories(smile PRIVATE src external/libbtc/include)&#10;&#10;target_link_libraries(smile&#10;        OpenSSL::Crypto&#10;        nlohmann_json::nlohmann_json&#10;)" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.20)&#10;project(smile LANGUAGES C CXX)&#10;&#10;set(CMAKE_TOOLCHAIN_FILE&#10;        &quot;${CMAKE_CURRENT_SOURCE_DIR}/external/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;&#10;        CACHE STRING &quot;Vcpkg toolchain file&quot;)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_EXPORT_COMPILE_COMMANDS ON)&#10;&#10;# Integrate vcpkg&#10;if(DEFINED ENV{VCPKG_ROOT})&#10;    set(CMAKE_TOOLCHAIN_FILE &quot;$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake&quot;&#10;            CACHE STRING &quot;&quot;)&#10;endif()&#10;&#10;find_package(OpenSSL REQUIRED)&#10;find_package(nlohmann_json REQUIRED)&#10;&#10;file(GLOB SRC_FILES &quot;${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp&quot;)&#10;add_executable(smile ${SRC_FILES})&#10;&#10;target_include_directories(smile PRIVATE src external/libbtc/include)&#10;&#10;target_link_libraries(smile&#10;        OpenSSL::Crypto&#10;        nlohmann_json::nlohmann_json&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="&lt;p align=&quot;center&quot;&gt;&#10;  &lt;img src=&quot;smile.png&quot; alt=&quot;SMILE&quot; width=&quot;25%&quot; /&gt;&#10;&lt;/p&gt;&#10;&#10;&#10;&#10;&#10;&#10;# SMILE — SIM Mobile Identity for Ledgers&#10;&#10;**Turn your SIM card into a crypto wallet. No applets. No passwords. No KYC.**&#10;&#10;&#10;SMILE is a breakthrough protocol that derives blockchain wallets directly from SIM cards,&#10;using open standards, 2G-5G telecom APIs, and the trusted cryptography already built into mobile networks.&#10;&#10;Every SIM card already belongs to the world’s largest identity network. &#10;SMILE turns it into the world’s most universal crypto wallet.&#10;&#10;With SMILE, your SIM card instantly becomes a secure, self-sovereign blockchain identity —&#10;seamlessly integrated with the x402 protocol to enable trustless transactions, instant onboarding, &#10;and hardware-grade wallet security.&#10;&#10;&#10;Your phone number is now your wallet identity.&#10;&#10;&#10;&#10;&#10;&#10;---&#10;&#10;##  What SMILE Does&#10;&#10;-  **Derives a BIP-32/39 HD wallet** from the SIM’s AKA authentication keys&#10;-  **Uses only existing 3G/4G/5G SIM commands** — no Java Card or carrier mods&#10;-  **HKDF → BIP seed → master key** — all on device, zero exposure of Ki or K&#10;&#10;---&#10;&#10;##  Why It Matters&#10;&#10;- **No fragile seed UX** — the SIM *is* your root of trust&#10;- **Pay-per-use connectivity**: pay per MB, per minute, per sensor tick&#10;- **Tap-to-transact IoT**: vending machines, EV chargers, drones, kiosks&#10;- **Carrier ↔ crypto flywheel**: airtime, rewards, promos → on-chain assets&#10;- **Signed operations**: firmware updates, door unlocks, telemetry notarization&#10;&#10;---&#10;&#10;&#10;&lt;summary&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/summary&gt;&#10;&#10;- [What SMILE Does](#what-smile-does)&#10;- [Why It Matters](#why-it-matters)&#10;- [Build and Run SMILE](#building-reference-implementation)&#10;- [Using `SmileSeedDerivation` Class](#using-smileseedderivation-class)&#10;    - [Overview](#overview)&#10;    - [Public Interface Summary](#public-interface-summary)&#10;    - [`deriveBIP32MasterSeed2G`](#derivebip32masterseed2g)&#10;    - [`deriveBIP32MasterSeed3G`](#derivebip32masterseed3g)&#10;    - [`deriveBIP32MasterSeed4G`](#derivebip32masterseed4g)&#10;    - [`deriveBIP32MasterSeed5G`](#derivebip32masterseed5g)&#10;    - [References](#references)&#10;- [Using `Bip32Wallet` Class](#using-bip32wallet-class)&#10;    - [`deriveWalletPrivateKey`](#derivewalletprivatekey)&#10;    - [`computePublicKeyFromPrivate`](#computepublickeyfromprivate)&#10;- [Mathematical Spec: SMILE BIP32 Master Seed Derivation](#spec-bip32-master-seed-derivation-using-cellular-authentication-2g5g)&#10;    - [1. Overview](#1-overview)&#10;    - [2. Notation](#2-notation)&#10;    - [3. Cryptographic Framework](#3-cryptographic-framework)&#10;        - [3.1. HKDF (RFC 5869)](#31-hkdf-rfc-5869)&#10;    - [4. deriveBIP32MasterSeed2G](#4-2g-derivebip32masterseed2g)&#10;    - [5. deriveBIP32MasterSeed3G](#5-3g-derivebip32masterseed3g)&#10;    - [6. deriveBIP32MasterSeed4G](#6-4g-derivebip32masterseed4g)&#10;    - [7. deriveBIP32MasterSeed5G](#7-5g-derivebip32masterseed5g)&#10;    - [8. Security Discussion](#8-security-discussion)&#10;    - [9. Example End-to-End Derivation Flow (5G)](#9-example-end-to-end-derivation-flow-5g)&#10;    - [10. Implementation Notes](#10-implementation-notes)&#10;    - [11. Security Level Summary](#11-security-level-summary)&#10;&#10;---&#10;&#10;##  Build and Run SMILE&#10;&#10;### 1. Clone the repository&#10;&#10;```bash&#10;git clone https://github.com/skalenetwork/smile --recursive&#10;```&#10;&#10;### 2. Bootstrap and install dependencies using vcpkg&#10;&#10;```bash&#10;./external/vcpkg/bootstrap-vcpkg.sh&#10;./external/vcpkg/vcpkg install&#10;```&#10;&#10;### 3. Configure and build with CMake&#10;&#10;```bash&#10;cmake -S . -B build   -DCMAKE_BUILD_TYPE=Release   -DCMAKE_TOOLCHAIN_FILE=external/vcpkg/scripts/buildsystems/vcpkg.cmake   -DVCPKG_FEATURE_FLAGS=manifests   -DVCPKG_TARGET_TRIPLET=x64-linux&#10;&#10;cmake --build build -j&#10;```&#10;&#10;### 4. Run the SMILE demo&#10;&#10;```bash&#10;build/smile&#10;```&#10;&#10;---&#10;&#10;##  Notes&#10;&#10;- ✅ **Tested on:** Ubuntu 22.04 and later  &#10;-  **Coming soon:** Windows and macOS builds  &#10;&#10;&#10;---&#10;&#10;# Using `SmileSeedDerivation` Class&#10;&#10;**Usage:** `#include SmileSeedDerivation.h`&#10;&#10;## Overview&#10;&#10;`SmileSeedDerivation` provides a unified cryptographic abstraction for deriving **32-byte deterministic master seeds** (e.g., for BIP-32 hierarchical key systems) directly from cellular authentication primitives across multiple generations — **2G (GSM)**, **3G (UMTS-AKA)**, **4G (EPS-AKA)**, and **5G (5G-AKA)**.&#10;&#10;Each generation uses the same conceptual structure:&#10;&#10;| Generation | Underlying Standard | Key Algorithm | Output |&#10;|-------------|---------------------|----------------|---------|&#10;| 2G | GSM / TS 51.011 | COMP128-1 (A3/A8) → SHA-256 | 32-byte seed |&#10;| 3G | TS 33.102 / TS 35.206 | Milenage → SHA-256 | 32-byte seed |&#10;| 4G | TS 33.401 | EPS-AKA KDF → SHA-256 | 32-byte seed |&#10;| 5G | TS 33.501 | 5G-AKA KDF → HKDF-SHA-256 | 32-byte seed |&#10;&#10;&#10;---&#10;&#10;## Public Interface Summary&#10;&#10;| Function | Input | Core Algorithm | Output |&#10;|-----------|--------|----------------|---------|&#10;| `deriveBIP32MasterSeed2G` | RAND, Ki | COMP128-1 → HKDF-SHA-256(SRES ‖ Kc) | 32-byte seed |&#10;| `deriveBIP32MasterSeed3G` | RAND, AUTN, K, OPc, AMF | Milenage → HKDF-SHA-256(RES ‖ CK ‖ IK) | 32-byte seed |&#10;| `deriveBIP32MasterSeed4G` | RAND, AUTN, K, OPc, AMF, SNN | EPS-AKA KDF → HKDF-SHA-256(RES ‖ K_ASME) | 32-byte seed |&#10;| `deriveBIP32MasterSeed5G` | RAND, AUTN, K, OPc, AMF, SNN | 5G-AKA KDF → HKDF-SHA-256(K_SEAF) | 32-byte seed |&#10;&#10;---&#10;&#10;## `deriveBIP32MasterSeed2G`&#10;&#10;```cpp&#10;static array32 deriveBIP32MasterSeed2G(const array16 &amp;rand, const array16 &amp;ki);&#10;```&#10;&#10;### Description&#10;Derives a **32-byte BIP-32 master seed** from GSM (2G) authentication results.&#10;&#10;### Parameters&#10;| Name | Size | Description |&#10;|------|------|-------------|&#10;| `rand` | 16 bytes | Network random challenge (RAND) |&#10;| `ki` | 16 bytes | Subscriber secret key stored on the SIM card (Ki) |&#10;&#10;### Returns&#10;&#10;- 32-byte seed. Throws exception on failure.&#10;&#10;### Notes&#10;- COMP128-1 used internally as demonstration; real SIMs may use proprietary A3/A8 variants.&#10;&#10;---&#10;&#10;## `deriveBIP32MasterSeed3G`&#10;&#10;```cpp&#10;static array32 deriveBIP32MasterSeed3G(&#10;    const array16 &amp;rand,&#10;    const array16 &amp;autn,&#10;    const array16 &amp;k,&#10;    const array16 &amp;opc,&#10;    const array2 &amp;amf);&#10;```&#10;&#10;### Description&#10;Implements **3G/UMTS-AKA** (Authentication and Key Agreement), and derives a  **32-byte BIP-32 master seed** &#10;from the authentication results (RES, CK, IK).&#10;&#10;&#10;### Parameters&#10;| Name | Size | Description                                                             |&#10;|------|------|-------------------------------------------------------------------------|&#10;| `rand` | 16 B | Network challenge RAND                                                  |&#10;| `autn` | 16 B | AUTN = (SQN ⊕ AK) ‖ AMF ‖ MAC-A                                         |&#10;| `k` | 16 B | Subscriber long-term key K                                              |&#10;| `opc` | 16 B | Operator variant constant OPc = OP ⊕ AES_K(OP). Fixed per operator.     |&#10;| `amf` | 2 B | Authentication Management Field (typically 0x8000). Fixed per operator. |&#10;&#10;### Returns&#10;- 32-byte seed. Throws exception on failure.&#10;&#10;### Standards&#10;- 3GPP TS 33.102 § 6.3&#10;- 3GPP TS 35.205 – 35.207 (Milenage)&#10;&#10;---&#10;&#10;## `deriveBIP32MasterSeed4G`&#10;&#10;```cpp&#10;static array32 deriveBIP32MasterSeed4G(&#10;    const array16 &amp;rand,&#10;    const array16 &amp;autn,&#10;    const array16 &amp;k,&#10;    const array16 &amp;opc,&#10;    const array2 &amp;amf,&#10;    const std::string &amp;snn);&#10;```&#10;&#10;### Description&#10;Derives a  **32-byte BIP-32 master seed** from LTE/EPS-AKA authentication results (RES, K_ASME).&#10;&#10;### Parameters&#10;| Name | Description                                                                             |&#10;|------|-----------------------------------------------------------------------------------------|&#10;| `rand` | 16-byte network challenge RAND                                                          |&#10;| `autn` | 16-byte authentication token AUTN                                                       |&#10;| `k` | Subscriber key K                                                                        |&#10;| `opc` | Operator constant OPc. Fixed per operator.                                              |&#10;| `amf` | 2-byte Authentication Management Field. Fixed per operator.                             |&#10;| `snn` | **Serving Network Name** (e.g., `&quot;mnc410.mcc310.3gppnetwork.org&quot;`). Fixed per operator. |&#10;&#10;### Returns&#10;- 32-byte seed. Throws exception on failure.&#10;&#10;### Standards&#10;- 3GPP TS 33.401 Annex A.2–A.4&#10;- 3GPP TS 23.003 § 28.7 (SNN format)&#10;&#10;---&#10;&#10;## `deriveBIP32MasterSeed5G`&#10;&#10;```cpp&#10;static array32 deriveBIP32MasterSeed5G(&#10;    const array16 &amp;rand,&#10;    const array16 &amp;autn,&#10;    const array16 &amp;k,&#10;    const array16 &amp;opc,&#10;    const array2 &amp;amf,&#10;    const std::string &amp;snn);&#10;```&#10;&#10;### Description&#10;Computes a  **32-byte BIP-32 master seed**  from 5G-AKA authentication results (`RES*`, `K_SEAF`).&#10;&#10;### Parameters&#10;| Name | Description                                                      |&#10;|------|------------------------------------------------------------------|&#10;| `rand` | 16-byte RAND                                                     |&#10;| `autn` | 16-byte AUTN                                                     |&#10;| `k` | 16-byte subscriber key                                           |&#10;| `opc` | 16-byte operator variant constant. Fixed per operator            |&#10;| `amf` | 2-byte AMF. Fixed per operator.                                  |&#10;| `snn` | Serving Network Name (as per 3GPP TS 33.501). Fixed per operator |&#10;&#10;### Returns&#10;- 32-byte seed. Throws exception on failure.&#10;&#10;&#10;### Standards&#10;- 3GPP TS 33.501 Annex A.4–A.6&#10;- RFC 5869 (HKDF)&#10;- 3GPP TS 24.501 (SNN naming)&#10;&#10;---&#10;&#10;&#10;&#10;### References&#10;&#10;| Standard | Document | Description |&#10;|-----------|-----------|--------------|&#10;| GSM / 2G | 3GPP TS 51.011 | SIM–ME interface, A3/A8 |&#10;| 3G | 3GPP TS 33.102 / 35.205-207 | UMTS AKA / Milenage |&#10;| 4G | 3GPP TS 33.401 | EPS AKA KDF for K_ASME |&#10;| 5G | 3GPP TS 33.501 | 5G-AKA KDF for K_SEAF, RES* |&#10;| KDF | RFC 5869 | HMAC-based Key Derivation Function |&#10;&#10;---&#10;&#10;&#10;# Using `Bip32Wallet` Class&#10;&#10;**Header:** `#include &quot;Bip32Wallet.h&quot;`&#10;&#10;## Overview&#10;&#10;`Bip32Wallet` provides a lightweight, standards-compliant implementation of the **BIP32 hierarchical deterministic (HD) wallet key derivation** process.&#10;&#10;It exposes stateless cryptographic helpers for deriving:&#10;- **child private keys** (both hardened and non-hardened) from any seed, and&#10;- the corresponding **compressed public key** on the secp256k1 elliptic curve.&#10;&#10;---&#10;&#10;## Public Interface Summary&#10;&#10;| Function | Input | Output | Description |&#10;|-----------|--------|---------|-------------|&#10;| [`deriveWalletPrivateKey`](#derivewalletprivatekey) | seed (32 B), index (uint32) | child private key (32 B) | Derives a child private key from a BIP32 seed |&#10;| [`computePublicKeyFromPrivate`](#computepublickeyfromprivate) | private key (32 B) | compressed pubkey (33 B) | Computes compressed secp256k1 public key |&#10;&#10;---&#10;&#10;## `deriveWalletPrivateKey`&#10;&#10;```cpp&#10;static array32 deriveWalletPrivateKey(const array32&amp; seed, uint32_t index = 0);&#10;```&#10;&#10;### Description&#10;&#10;Derives a **child private key** from a given 32-byte BIP32 seed, following the standard BIP32 key derivation procedure.  &#10;&#10;#&#10;### Parameters&#10;&#10;| Name | Type | Description |&#10;|------|------|--------------|&#10;| `seed` | `array32` | 32-byte BIP32 master seed |&#10;| `index` | `uint32_t` | Child index; bit 31 (0x80000000) selects hardened derivation. Default = `0` |&#10;&#10;### Returns&#10;&#10;- 32-byte derived child private key (`array32`). Throws exception on failure.&#10;&#10;---&#10;&#10;## `computePublicKeyFromPrivate`&#10;&#10;```cpp&#10;static std::array&lt;uint8_t, 33&gt; computePublicKeyFromPrivate(const array32 &amp;privkey);&#10;```&#10;&#10;### Description&#10;&#10;Computes a **compressed public key** (33 bytes) from a given private key.&#10;&#10;### Parameters&#10;&#10;| Name | Type | Description |&#10;|------|------|--------------|&#10;| `privkey` | `array32` | 32-byte secp256k1 private key |&#10;&#10;### Returns&#10;&#10;- 33-byte compressed public key. Throws exception on failure.&#10;&#10;---&#10;&#10;## Cryptographic Notes&#10;&#10;- Curve parameters follow **secp256k1** (Bitcoin, Ethereum, SKALE, etc.).&#10;&#10;---&#10;&#10;## Standards &amp; References&#10;&#10;| Specification | Section | Description |&#10;|----------------|----------|--------------|&#10;| [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) | §4–§5 | Hierarchical Deterministic Wallets |&#10;| [SECP256K1](https://www.secg.org/sec2-v2.pdf) | §2.7 | Elliptic Curve Parameters |&#10;| [RFC 2104](https://www.rfc-editor.org/rfc/rfc2104) | — | HMAC Construction |&#10;| [OpenSSL EVP / EC API](https://www.openssl.org/docs/man3.0/man7/evp.html) | — | Cryptographic primitives |&#10;&#10;&#10;&#10;&#10;&#10;# Mathematical Spec: SMILE BIP32 Master Seed Derivation&#10;&#10;**Standards:**&#10;- 3GPP TS 33.102 (3G Security Architecture)&#10;- 3GPP TS 33.401 (LTE Security Architecture)&#10;- 3GPP TS 33.501 (5G Security Architecture)&#10;- RFC 5869: HMAC-based Key Derivation Function (HKDF)&#10;- BIP32: Hierarchical Deterministic Wallets&#10;&#10;---&#10;&#10;## 1. Overview&#10;&#10;This specification defines a set of deterministic algorithms for deriving a **BIP32 master seed** using **SIM/USIM/ISIM-based authentication primitives** from mobile communication systems (2G–5G).&#10;&#10;The approach leverages cryptographically secure values generated during cellular authentication — such as **SRES**, **Kc**, **CK**, **IK**, **K_ASME**, and **K_SEAF** — as entropy sources for the BIP32 root seed.&#10;&#10;The final seed derivation uses the standardized **HKDF** function (RFC 5869) over the authentication-derived keying material.&#10;&#10;---&#10;&#10;## 2. Notation&#10;&#10;| Symbol | Meaning |&#10;|---------|----------|&#10;| `RAND` | Random challenge generated by the network |&#10;| `AUTN` | Authentication token |&#10;| `K` | Subscriber permanent key (stored securely in SIM/USIM/ISIM) |&#10;| `OPc` | Operator variant key constant (Milenage parameter) |&#10;| `AMF` | Authentication Management Field |&#10;| `SNN` | Serving Network Name |&#10;| `SRES` | Signed response (2G AKA output) |&#10;| `Kc` | Cipher key (2G AKA output) |&#10;| `CK` | Cipher key (3G/4G/5G AKA output) |&#10;| `IK` | Integrity key (3G/4G/5G AKA output) |&#10;| `AK` | Anonymity key (3G/4G/5G AKA output) |&#10;| `K_ASME` | Access Security Management Entity key (4G) |&#10;| `K_SEAF` | Security Anchor Function key (5G) |&#10;| `HMAC_SHA256(key, data)` | HMAC using SHA-256 |&#10;| `HKDF_Extract(salt, IKM)` | RFC 5869 extract stage |&#10;| `HKDF_Expand(PRK, info, L)` | RFC 5869 expand stage |&#10;| `‖` | Byte concatenation |&#10;&#10;---&#10;&#10;## 3. Cryptographic Framework&#10;&#10;### 3.1. HKDF (RFC 5869)&#10;&#10;RFC 5869 defines the HMAC-based Key Derivation Function (HKDF), &#10;a simple and secure method for deriving strong cryptographic keys from initial keying material using HMAC. &#10;It standardizes a two-step process—extract and expand—to ensure key separation, uniformity, and resistance &#10;to entropy loss or bias in the input material.&#10;&#10;Let:&#10;- `IKM` be the input keying material (entropy source)&#10;- `salt` be an optional context string (domain separation)&#10;- `info` be an optional identifier for derived key usage&#10;- `L` be the desired output length (32 bytes)&#10;&#10;Then:&#10;&#10;```&#10;PRK = HMAC_SHA256(salt, IKM)&#10;OKM = HMAC_SHA256(PRK, info || 0x01)&#10;Seed = OKM[0..31]&#10;```&#10;&#10;---&#10;&#10;## 4.  deriveBIP32MasterSeed2G&#10;&#10;### 4.1. Authentication Source&#10;&#10;2G authentication (GSM AKA) yields:&#10;&#10;```&#10;(SRES, Kc) = A3/A8(K, RAND)&#10;```&#10;&#10;- `SRES`: 32-bit signed response&#10;- `Kc`: 64-bit session key&#10;&#10;### 4.2. Input Keying Material (IKM)&#10;&#10;```&#10;IKM_2G = SRES || Kc&#10;```&#10;&#10;(12 bytes total)&#10;&#10;### 4.3. HKDF Context&#10;&#10;- Salt = &quot;SMILE|2G|salt|v1&quot;&#10;- Info = &quot;SMILE|2G|seed|v1&quot;&#10;&#10;### 4.4. Derivation Equation&#10;&#10;```&#10;Seed_2G = HKDF_SHA256(IKM_2G, Salt, Info)&#10;```&#10;&#10;### 4.5. Output&#10;&#10;- 32-byte (32-byte) seed suitable as BIP32 master seed.&#10;- Entropy source limited (~96 bits), so use only for deterministic derivations, not high-assurance wallet seeds.&#10;&#10;---&#10;&#10;## 5. deriveBIP32MasterSeed3G&#10;&#10;### 5.1. Authentication Source&#10;&#10;3G AKA (Milenage) yields:&#10;&#10;```&#10;(RES, CK, IK, AK) = f1..5(K, RAND, OPc, AMF)&#10;```&#10;&#10;- `CK`: 128-bit cipher key&#10;- `IK`: 128-bit integrity key&#10;&#10;### 5.2. Input Keying Material&#10;&#10;```&#10;IKM_3G = CK || IK&#10;```&#10;(256 bits)&#10;&#10;### 5.3. Salt Construction&#10;&#10;```&#10;ctx = RAND || AUTN || &quot;SMILE|3G|salt|v1&quot;&#10;Salt_3G = SHA256(ctx)&#10;```&#10;&#10;### 5.4. HKDF Derivation&#10;&#10;```&#10;Seed_3G = HKDF_SHA256(IKM_3G, Salt_3G, &quot;SMILE|3G|seed|v1&quot;)&#10;```&#10;&#10;### 5.5. Output&#10;&#10;- 32-byte BIP32 seed with high entropy (~256 bits).&#10;- Combines network challenge RAND with key material for domain separation.&#10;&#10;---&#10;&#10;## 6. deriveBIP32MasterSeed4G&#10;&#10;### 6.1. Authentication Source&#10;&#10;LTE AKA yields the derived **Access Security Management Entity key** `K_ASME` from `CK` and `IK` using:&#10;&#10;```&#10;K_ASME = HMAC_SHA256(CK||IK, FC||SNN||L0||(SQN⊕AK)||L1)&#10;```&#10;&#10;(Per 3GPP TS 33.401 §A.2.1, with FC = 0x10.)&#10;&#10;### 6.2. Input Keying Material&#10;&#10;```&#10;IKM_4G = K_ASME&#10;```&#10;(256 bits)&#10;&#10;### 6.3. Salt Construction&#10;&#10;```&#10;ctx = SNN || &quot;|&quot; || &quot;SMILE|4G|salt|v1&quot;&#10;Salt_4G = SHA256(ctx)&#10;```&#10;&#10;### 6.4. HKDF Derivation&#10;&#10;```&#10;Seed_4G = HKDF_SHA256(IKM_4G, Salt_4G, &quot;SMILE|4G|seed|v1&quot;)&#10;```&#10;&#10;### 6.5. Output&#10;&#10;- 32-byte BIP32 seed.&#10;- Strong cryptographic entropy, sourced from LTE authentication hierarchy.&#10;- Safe for generating HD wallet roots tied to mobile identity.&#10;&#10;---&#10;&#10;## 7. deriveBIP32MasterSeed5G&#10;&#10;### 7.1. Authentication Source&#10;&#10;5G AKA (TS 33.501) derives the following hierarchy:&#10;&#10;```&#10;K_AUSF = HMAC_SHA256(CK||IK, FC||SNN||L0||(SQN⊕AK)||L1), FC = 0x6A&#10;K_SEAF = HMAC_SHA256(K_AUSF, FC||SNN||L0), FC = 0x6B&#10;```&#10;&#10;### 7.2. Input Keying Material&#10;&#10;```&#10;IKM_5G = K_SEAF&#10;```&#10;&#10;### 7.3. Salt Construction&#10;&#10;```&#10;ctx = SNN || &quot;|&quot; || &quot;SMILE|5G|salt|v1&quot;&#10;Salt_5G = SHA256(ctx)&#10;```&#10;&#10;### 7.4. HKDF Derivation&#10;&#10;```&#10;Seed_5G = HKDF_SHA256(IKM_5G, Salt_5G, &quot;SMILE|5G|seed|v1&quot;)&#10;```&#10;&#10;### 7.5. Output&#10;&#10;- 32-byte master seed (BIP32 m/ root).&#10;- Entropy sourced from 5G key hierarchy (K_SEAF), which derives from K via CK/IK → K_AUSF → K_SEAF.&#10;- Represents cryptographic coupling between SIM identity and HD wallet seed.&#10;&#10;---&#10;&#10;## 8. Security Discussion&#10;&#10;1. **Entropy:**&#10;    - 2G: ≤ 96 bits&#10;    - 3G/4G/5G: ≥ 256 bits (AES-based + random challenge)&#10;&#10;2. **Forward Secrecy:**&#10;    - Each derivation depends on network RAND, ensuring session uniqueness.&#10;&#10;3. **Domain Separation:**&#10;    - HKDF salt and info labels include generation and versioning tags (SMILE|xG|...|v1).&#10;&#10;4. **Compatibility:**&#10;    - Final output format (32 bytes) matches BIP32 master seed input for:&#10;      ```&#10;      (m, c) = HMAC_SHA512(&quot;Bitcoin seed&quot;, Seed)&#10;      ```&#10;&#10;---&#10;&#10;## 9. Example End-to-End Derivation Flow (5G)&#10;&#10;```&#10;Step 1: AKA → CK, IK, AK, RES&#10;Step 2: K_AUSF = HMAC_SHA256(CK||IK, 0x6A||SNN||L0||(SQN⊕AK)||L1)&#10;Step 3: K_SEAF = HMAC_SHA256(K_AUSF, 0x6B||SNN||L0)&#10;Step 4: Salt = SHA256(SNN||&quot;|&quot;||&quot;SMILE|5G|salt|v1&quot;)&#10;Step 5: Seed = HKDF_SHA256(K_SEAF, Salt, &quot;SMILE|5G|seed|v1&quot;)&#10;Output: Seed_5G ∈ {0,1}^256&#10;```&#10;&#10;---&#10;&#10;## 10. Implementation Notes&#10;&#10;- All HKDF operations use HMAC-SHA256 as the PRF.&#10;- All salts and info strings are ASCII-encoded.&#10;- The seed output can be directly passed to BIP32 as the entropy input for HMAC-SHA512 keychain derivation.&#10;&#10;---&#10;&#10;## 11. Security Level Summary&#10;&#10;| Generation | Entropy Source | Algorithmic Base | Cryptographic Strength |&#10;|-------------|----------------|------------------|------------------------|&#10;| 2G | (SRES‖Kc) | COMP128 / A3/A8 | Weak / Legacy |&#10;| 3G | (CK‖IK) via Milenage | AES-128 | Strong |&#10;| 4G | K_ASME (HMAC-SHA256) | AES-128 + SHA256 | Strong |&#10;| 5G | K_SEAF (HMAC-SHA256 chain) | AES-128 + SHA256 | Very Strong |&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="# SMILE&#10;&#10;[![CI](https://github.com/skalenetwork/smile/actions/workflows/ci.yml/badge.svg)](https://github.com/skalenetwork/smile/actions/workflows/ci.yml)&#10;&#10;## Overview&#10;&#10;&lt;p align=&quot;center&quot;&gt;&#10;  &lt;img src=&quot;smile.png&quot; alt=&quot;SMILE&quot; width=&quot;25%&quot; /&gt;&#10;&lt;/p&gt;&#10;&#10;&#10;&#10;&#10;&#10;# SMILE — SIM Mobile Identity for Ledgers&#10;&#10;**Turn your SIM card into a crypto wallet. No applets. No passwords. No KYC.**&#10;&#10;&#10;SMILE is a breakthrough protocol that derives blockchain wallets directly from SIM cards,&#10;using open standards, 2G-5G telecom APIs, and the trusted cryptography already built into mobile networks.&#10;&#10;Every SIM card already belongs to the world’s largest identity network. &#10;SMILE turns it into the world’s most universal crypto wallet.&#10;&#10;With SMILE, your SIM card instantly becomes a secure, self-sovereign blockchain identity —&#10;seamlessly integrated with the x402 protocol to enable trustless transactions, instant onboarding, &#10;and hardware-grade wallet security.&#10;&#10;&#10;Your phone number is now your wallet identity.&#10;&#10;&#10;&#10;&#10;&#10;---&#10;&#10;##  What SMILE Does&#10;&#10;-  **Derives a BIP-32/39 HD wallet** from the SIM’s AKA authentication keys&#10;-  **Uses only existing 3G/4G/5G SIM commands** — no Java Card or carrier mods&#10;-  **HKDF → BIP seed → master key** — all on device, zero exposure of Ki or K&#10;&#10;---&#10;&#10;##  Why It Matters&#10;&#10;- **No fragile seed UX** — the SIM *is* your root of trust&#10;- **Pay-per-use connectivity**: pay per MB, per minute, per sensor tick&#10;- **Tap-to-transact IoT**: vending machines, EV chargers, drones, kiosks&#10;- **Carrier ↔ crypto flywheel**: airtime, rewards, promos → on-chain assets&#10;- **Signed operations**: firmware updates, door unlocks, telemetry notarization&#10;&#10;---&#10;&#10;&#10;&lt;summary&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/summary&gt;&#10;&#10;- [What SMILE Does](#what-smile-does)&#10;- [Why It Matters](#why-it-matters)&#10;- [Build and Run SMILE](#building-reference-implementation)&#10;- [Using `SmileSeedDerivation` Class](#using-smileseedderivation-class)&#10;    - [Overview](#overview)&#10;    - [Public Interface Summary](#public-interface-summary)&#10;    - [`deriveBIP32MasterSeed2G`](#derivebip32masterseed2g)&#10;    - [`deriveBIP32MasterSeed3G`](#derivebip32masterseed3g)&#10;    - [`deriveBIP32MasterSeed4G`](#derivebip32masterseed4g)&#10;    - [`deriveBIP32MasterSeed5G`](#derivebip32masterseed5g)&#10;    - [References](#references)&#10;- [Using `Bip32Wallet` Class](#using-bip32wallet-class)&#10;    - [`deriveWalletPrivateKey`](#derivewalletprivatekey)&#10;    - [`computePublicKeyFromPrivate`](#computepublickeyfromprivate)&#10;- [Mathematical Spec: SMILE BIP32 Master Seed Derivation](#spec-bip32-master-seed-derivation-using-cellular-authentication-2g5g)&#10;    - [1. Overview](#1-overview)&#10;    - [2. Notation](#2-notation)&#10;    - [3. Cryptographic Framework](#3-cryptographic-framework)&#10;        - [3.1. HKDF (RFC 5869)](#31-hkdf-rfc-5869)&#10;    - [4. deriveBIP32MasterSeed2G](#4-2g-derivebip32masterseed2g)&#10;    - [5. deriveBIP32MasterSeed3G](#5-3g-derivebip32masterseed3g)&#10;    - [6. deriveBIP32MasterSeed4G](#6-4g-derivebip32masterseed4g)&#10;    - [7. deriveBIP32MasterSeed5G](#7-5g-derivebip32masterseed5g)&#10;    - [8. Security Discussion](#8-security-discussion)&#10;    - [9. Example End-to-End Derivation Flow (5G)](#9-example-end-to-end-derivation-flow-5g)&#10;    - [10. Implementation Notes](#10-implementation-notes)&#10;    - [11. Security Level Summary](#11-security-level-summary)&#10;&#10;---&#10;&#10;##  Build and Run SMILE&#10;&#10;### 1. Clone the repository&#10;&#10;```bash&#10;git clone https://github.com/skalenetwork/smile --recursive&#10;```&#10;&#10;### 2. Bootstrap and install dependencies using vcpkg&#10;&#10;```bash&#10;./external/vcpkg/bootstrap-vcpkg.sh&#10;./external/vcpkg/vcpkg install&#10;```&#10;&#10;### 3. Configure and build with CMake&#10;&#10;```bash&#10;cmake -S . -B build   -DCMAKE_BUILD_TYPE=Release   -DCMAKE_TOOLCHAIN_FILE=external/vcpkg/scripts/buildsystems/vcpkg.cmake   -DVCPKG_FEATURE_FLAGS=manifests   -DVCPKG_TARGET_TRIPLET=x64-linux&#10;&#10;cmake --build build -j&#10;```&#10;&#10;### 4. Run the SMILE demo&#10;&#10;```bash&#10;build/smile&#10;```&#10;&#10;---&#10;&#10;##  Notes&#10;&#10;- ✅ **Tested on:** Ubuntu 22.04 and later  &#10;-  **Coming soon:** Windows and macOS builds  &#10;&#10;&#10;---&#10;&#10;# Using `SmileSeedDerivation` Class&#10;&#10;**Usage:** `#include SmileSeedDerivation.h`&#10;&#10;## Overview&#10;&#10;`SmileSeedDerivation` provides a unified cryptographic abstraction for deriving **32-byte deterministic master seeds** (e.g., for BIP-32 hierarchical key systems) directly from cellular authentication primitives across multiple generations — **2G (GSM)**, **3G (UMTS-AKA)**, **4G (EPS-AKA)**, and **5G (5G-AKA)**.&#10;&#10;Each generation uses the same conceptual structure:&#10;&#10;| Generation | Underlying Standard | Key Algorithm | Output |&#10;|-------------|---------------------|----------------|---------|&#10;| 2G | GSM / TS 51.011 | COMP128-1 (A3/A8) → SHA-256 | 32-byte seed |&#10;| 3G | TS 33.102 / TS 35.206 | Milenage → SHA-256 | 32-byte seed |&#10;| 4G | TS 33.401 | EPS-AKA KDF → SHA-256 | 32-byte seed |&#10;| 5G | TS 33.501 | 5G-AKA KDF → HKDF-SHA-256 | 32-byte seed |&#10;&#10;&#10;---&#10;&#10;## Public Interface Summary&#10;&#10;| Function | Input | Core Algorithm | Output |&#10;|-----------|--------|----------------|---------|&#10;| `deriveBIP32MasterSeed2G` | RAND, Ki | COMP128-1 → HKDF-SHA-256(SRES ‖ Kc) | 32-byte seed |&#10;| `deriveBIP32MasterSeed3G` | RAND, AUTN, K, OPc, AMF | Milenage → HKDF-SHA-256(RES ‖ CK ‖ IK) | 32-byte seed |&#10;| `deriveBIP32MasterSeed4G` | RAND, AUTN, K, OPc, AMF, SNN | EPS-AKA KDF → HKDF-SHA-256(RES ‖ K_ASME) | 32-byte seed |&#10;| `deriveBIP32MasterSeed5G` | RAND, AUTN, K, OPc, AMF, SNN | 5G-AKA KDF → HKDF-SHA-256(K_SEAF) | 32-byte seed |&#10;&#10;---&#10;&#10;## `deriveBIP32MasterSeed2G`&#10;&#10;```cpp&#10;static array32 deriveBIP32MasterSeed2G(const array16 &amp;rand, const array16 &amp;ki);&#10;```&#10;&#10;### Description&#10;Derives a **32-byte BIP-32 master seed** from GSM (2G) authentication results.&#10;&#10;### Parameters&#10;| Name | Size | Description |&#10;|------|------|-------------|&#10;| `rand` | 16 bytes | Network random challenge (RAND) |&#10;| `ki` | 16 bytes | Subscriber secret key stored on the SIM card (Ki) |&#10;&#10;### Returns&#10;&#10;- 32-byte seed. Throws exception on failure.&#10;&#10;### Notes&#10;- COMP128-1 used internally as demonstration; real SIMs may use proprietary A3/A8 variants.&#10;&#10;---&#10;&#10;## `deriveBIP32MasterSeed3G`&#10;&#10;```cpp&#10;static array32 deriveBIP32MasterSeed3G(&#10;    const array16 &amp;rand,&#10;    const array16 &amp;autn,&#10;    const array16 &amp;k,&#10;    const array16 &amp;opc,&#10;    const array2 &amp;amf);&#10;```&#10;&#10;### Description&#10;Implements **3G/UMTS-AKA** (Authentication and Key Agreement), and derives a  **32-byte BIP-32 master seed** &#10;from the authentication results (RES, CK, IK).&#10;&#10;&#10;### Parameters&#10;| Name | Size | Description                                                             |&#10;|------|------|-------------------------------------------------------------------------|&#10;| `rand` | 16 B | Network challenge RAND                                                  |&#10;| `autn` | 16 B | AUTN = (SQN ⊕ AK) ‖ AMF ‖ MAC-A                                         |&#10;| `k` | 16 B | Subscriber long-term key K                                              |&#10;| `opc` | 16 B | Operator variant constant OPc = OP ⊕ AES_K(OP). Fixed per operator.     |&#10;| `amf` | 2 B | Authentication Management Field (typically 0x8000). Fixed per operator. |&#10;&#10;### Returns&#10;- 32-byte seed. Throws exception on failure.&#10;&#10;### Standards&#10;- 3GPP TS 33.102 § 6.3&#10;- 3GPP TS 35.205 – 35.207 (Milenage)&#10;&#10;---&#10;&#10;## `deriveBIP32MasterSeed4G`&#10;&#10;```cpp&#10;static array32 deriveBIP32MasterSeed4G(&#10;    const array16 &amp;rand,&#10;    const array16 &amp;autn,&#10;    const array16 &amp;k,&#10;    const array16 &amp;opc,&#10;    const array2 &amp;amf,&#10;    const std::string &amp;snn);&#10;```&#10;&#10;### Description&#10;Derives a  **32-byte BIP-32 master seed** from LTE/EPS-AKA authentication results (RES, K_ASME).&#10;&#10;### Parameters&#10;| Name | Description                                                                             |&#10;|------|-----------------------------------------------------------------------------------------|&#10;| `rand` | 16-byte network challenge RAND                                                          |&#10;| `autn` | 16-byte authentication token AUTN                                                       |&#10;| `k` | Subscriber key K                                                                        |&#10;| `opc` | Operator constant OPc. Fixed per operator.                                              |&#10;| `amf` | 2-byte Authentication Management Field. Fixed per operator.                             |&#10;| `snn` | **Serving Network Name** (e.g., `&quot;mnc410.mcc310.3gppnetwork.org&quot;`). Fixed per operator. |&#10;&#10;### Returns&#10;- 32-byte seed. Throws exception on failure.&#10;&#10;### Standards&#10;- 3GPP TS 33.401 Annex A.2–A.4&#10;- 3GPP TS 23.003 § 28.7 (SNN format)&#10;&#10;---&#10;&#10;## `deriveBIP32MasterSeed5G`&#10;&#10;```cpp&#10;static array32 deriveBIP32MasterSeed5G(&#10;    const array16 &amp;rand,&#10;    const array16 &amp;autn,&#10;    const array16 &amp;k,&#10;    const array16 &amp;opc,&#10;    const array2 &amp;amf,&#10;    const std::string &amp;snn);&#10;```&#10;&#10;### Description&#10;Computes a  **32-byte BIP-32 master seed**  from 5G-AKA authentication results (`RES*`, `K_SEAF`).&#10;&#10;### Parameters&#10;| Name | Description                                                      |&#10;|------|------------------------------------------------------------------|&#10;| `rand` | 16-byte RAND                                                     |&#10;| `autn` | 16-byte AUTN                                                     |&#10;| `k` | 16-byte subscriber key                                           |&#10;| `opc` | 16-byte operator variant constant. Fixed per operator            |&#10;| `amf` | 2-byte AMF. Fixed per operator.                                  |&#10;| `snn` | Serving Network Name (as per 3GPP TS 33.501). Fixed per operator |&#10;&#10;### Returns&#10;- 32-byte seed. Throws exception on failure.&#10;&#10;&#10;### Standards&#10;- 3GPP TS 33.501 Annex A.4–A.6&#10;- RFC 5869 (HKDF)&#10;- 3GPP TS 24.501 (SNN naming)&#10;&#10;---&#10;&#10;&#10;&#10;### References&#10;&#10;| Standard | Document | Description |&#10;|-----------|-----------|--------------|&#10;| GSM / 2G | 3GPP TS 51.011 | SIM–ME interface, A3/A8 |&#10;| 3G | 3GPP TS 33.102 / 35.205-207 | UMTS AKA / Milenage |&#10;| 4G | 3GPP TS 33.401 | EPS AKA KDF for K_ASME |&#10;| 5G | 3GPP TS 33.501 | 5G-AKA KDF for K_SEAF, RES* |&#10;| KDF | RFC 5869 | HMAC-based Key Derivation Function |&#10;&#10;---&#10;&#10;&#10;# Using `Bip32Wallet` Class&#10;&#10;**Header:** `#include &quot;Bip32Wallet.h&quot;`&#10;&#10;## Overview&#10;&#10;`Bip32Wallet` provides a lightweight, standards-compliant implementation of the **BIP32 hierarchical deterministic (HD) wallet key derivation** process.&#10;&#10;It exposes stateless cryptographic helpers for deriving:&#10;- **child private keys** (both hardened and non-hardened) from any seed, and&#10;- the corresponding **compressed public key** on the secp256k1 elliptic curve.&#10;&#10;---&#10;&#10;## Public Interface Summary&#10;&#10;| Function | Input | Output | Description |&#10;|-----------|--------|---------|-------------|&#10;| [`deriveWalletPrivateKey`](#derivewalletprivatekey) | seed (32 B), index (uint32) | child private key (32 B) | Derives a child private key from a BIP32 seed |&#10;| [`computePublicKeyFromPrivate`](#computepublickeyfromprivate) | private key (32 B) | compressed pubkey (33 B) | Computes compressed secp256k1 public key |&#10;&#10;---&#10;&#10;## `deriveWalletPrivateKey`&#10;&#10;```cpp&#10;static array32 deriveWalletPrivateKey(const array32&amp; seed, uint32_t index = 0);&#10;```&#10;&#10;### Description&#10;&#10;Derives a **child private key** from a given 32-byte BIP32 seed, following the standard BIP32 key derivation procedure.  &#10;&#10;#&#10;### Parameters&#10;&#10;| Name | Type | Description |&#10;|------|------|--------------|&#10;| `seed` | `array32` | 32-byte BIP32 master seed |&#10;| `index` | `uint32_t` | Child index; bit 31 (0x80000000) selects hardened derivation. Default = `0` |&#10;&#10;### Returns&#10;&#10;- 32-byte derived child private key (`array32`). Throws exception on failure.&#10;&#10;---&#10;&#10;## `computePublicKeyFromPrivate`&#10;&#10;```cpp&#10;static std::array&lt;uint8_t, 33&gt; computePublicKeyFromPrivate(const array32 &amp;privkey);&#10;```&#10;&#10;### Description&#10;&#10;Computes a **compressed public key** (33 bytes) from a given private key.&#10;&#10;### Parameters&#10;&#10;| Name | Type | Description |&#10;|------|------|--------------|&#10;| `privkey` | `array32` | 32-byte secp256k1 private key |&#10;&#10;### Returns&#10;&#10;- 33-byte compressed public key. Throws exception on failure.&#10;&#10;---&#10;&#10;## Cryptographic Notes&#10;&#10;- Curve parameters follow **secp256k1** (Bitcoin, Ethereum, SKALE, etc.).&#10;&#10;---&#10;&#10;## Standards &amp; References&#10;&#10;| Specification | Section | Description |&#10;|----------------|----------|--------------|&#10;| [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) | §4–§5 | Hierarchical Deterministic Wallets |&#10;| [SECP256K1](https://www.secg.org/sec2-v2.pdf) | §2.7 | Elliptic Curve Parameters |&#10;| [RFC 2104](https://www.rfc-editor.org/rfc/rfc2104) | — | HMAC Construction |&#10;| [OpenSSL EVP / EC API](https://www.openssl.org/docs/man3.0/man7/evp.html) | — | Cryptographic primitives |&#10;&#10;&#10;&#10;&#10;&#10;# Mathematical Spec: SMILE BIP32 Master Seed Derivation&#10;&#10;**Standards:**&#10;- 3GPP TS 33.102 (3G Security Architecture)&#10;- 3GPP TS 33.401 (LTE Security Architecture)&#10;- 3GPP TS 33.501 (5G Security Architecture)&#10;- RFC 5869: HMAC-based Key Derivation Function (HKDF)&#10;- BIP32: Hierarchical Deterministic Wallets&#10;&#10;---&#10;&#10;## 1. Overview&#10;&#10;This specification defines a set of deterministic algorithms for deriving a **BIP32 master seed** using **SIM/USIM/ISIM-based authentication primitives** from mobile communication systems (2G–5G).&#10;&#10;The approach leverages cryptographically secure values generated during cellular authentication — such as **SRES**, **Kc**, **CK**, **IK**, **K_ASME**, and **K_SEAF** — as entropy sources for the BIP32 root seed.&#10;&#10;The final seed derivation uses the standardized **HKDF** function (RFC 5869) over the authentication-derived keying material.&#10;&#10;---&#10;&#10;## 2. Notation&#10;&#10;| Symbol | Meaning |&#10;|---------|----------|&#10;| `RAND` | Random challenge generated by the network |&#10;| `AUTN` | Authentication token |&#10;| `K` | Subscriber permanent key (stored securely in SIM/USIM/ISIM) |&#10;| `OPc` | Operator variant key constant (Milenage parameter) |&#10;| `AMF` | Authentication Management Field |&#10;| `SNN` | Serving Network Name |&#10;| `SRES` | Signed response (2G AKA output) |&#10;| `Kc` | Cipher key (2G AKA output) |&#10;| `CK` | Cipher key (3G/4G/5G AKA output) |&#10;| `IK` | Integrity key (3G/4G/5G AKA output) |&#10;| `AK` | Anonymity key (3G/4G/5G AKA output) |&#10;| `K_ASME` | Access Security Management Entity key (4G) |&#10;| `K_SEAF` | Security Anchor Function key (5G) |&#10;| `HMAC_SHA256(key, data)` | HMAC using SHA-256 |&#10;| `HKDF_Extract(salt, IKM)` | RFC 5869 extract stage |&#10;| `HKDF_Expand(PRK, info, L)` | RFC 5869 expand stage |&#10;| `‖` | Byte concatenation |&#10;&#10;---&#10;&#10;## 3. Cryptographic Framework&#10;&#10;### 3.1. HKDF (RFC 5869)&#10;&#10;RFC 5869 defines the HMAC-based Key Derivation Function (HKDF), &#10;a simple and secure method for deriving strong cryptographic keys from initial keying material using HMAC. &#10;It standardizes a two-step process—extract and expand—to ensure key separation, uniformity, and resistance &#10;to entropy loss or bias in the input material.&#10;&#10;Let:&#10;- `IKM` be the input keying material (entropy source)&#10;- `salt` be an optional context string (domain separation)&#10;- `info` be an optional identifier for derived key usage&#10;- `L` be the desired output length (32 bytes)&#10;&#10;Then:&#10;&#10;```&#10;PRK = HMAC_SHA256(salt, IKM)&#10;OKM = HMAC_SHA256(PRK, info || 0x01)&#10;Seed = OKM[0..31]&#10;```&#10;&#10;---&#10;&#10;## 4.  deriveBIP32MasterSeed2G&#10;&#10;### 4.1. Authentication Source&#10;&#10;2G authentication (GSM AKA) yields:&#10;&#10;```&#10;(SRES, Kc) = A3/A8(K, RAND)&#10;```&#10;&#10;- `SRES`: 32-bit signed response&#10;- `Kc`: 64-bit session key&#10;&#10;### 4.2. Input Keying Material (IKM)&#10;&#10;```&#10;IKM_2G = SRES || Kc&#10;```&#10;&#10;(12 bytes total)&#10;&#10;### 4.3. HKDF Context&#10;&#10;- Salt = &quot;SMILE|2G|salt|v1&quot;&#10;- Info = &quot;SMILE|2G|seed|v1&quot;&#10;&#10;### 4.4. Derivation Equation&#10;&#10;```&#10;Seed_2G = HKDF_SHA256(IKM_2G, Salt, Info)&#10;```&#10;&#10;### 4.5. Output&#10;&#10;- 32-byte (32-byte) seed suitable as BIP32 master seed.&#10;- Entropy source limited (~96 bits), so use only for deterministic derivations, not high-assurance wallet seeds.&#10;&#10;---&#10;&#10;## 5. deriveBIP32MasterSeed3G&#10;&#10;### 5.1. Authentication Source&#10;&#10;3G AKA (Milenage) yields:&#10;&#10;```&#10;(RES, CK, IK, AK) = f1..5(K, RAND, OPc, AMF)&#10;```&#10;&#10;- `CK`: 128-bit cipher key&#10;- `IK`: 128-bit integrity key&#10;&#10;### 5.2. Input Keying Material&#10;&#10;```&#10;IKM_3G = CK || IK&#10;```&#10;(256 bits)&#10;&#10;### 5.3. Salt Construction&#10;&#10;```&#10;ctx = RAND || AUTN || &quot;SMILE|3G|salt|v1&quot;&#10;Salt_3G = SHA256(ctx)&#10;```&#10;&#10;### 5.4. HKDF Derivation&#10;&#10;```&#10;Seed_3G = HKDF_SHA256(IKM_3G, Salt_3G, &quot;SMILE|3G|seed|v1&quot;)&#10;```&#10;&#10;### 5.5. Output&#10;&#10;- 32-byte BIP32 seed with high entropy (~256 bits).&#10;- Combines network challenge RAND with key material for domain separation.&#10;&#10;---&#10;&#10;## 6. deriveBIP32MasterSeed4G&#10;&#10;### 6.1. Authentication Source&#10;&#10;LTE AKA yields the derived **Access Security Management Entity key** `K_ASME` from `CK` and `IK` using:&#10;&#10;```&#10;K_ASME = HMAC_SHA256(CK||IK, FC||SNN||L0||(SQN⊕AK)||L1)&#10;```&#10;&#10;(Per 3GPP TS 33.401 §A.2.1, with FC = 0x10.)&#10;&#10;### 6.2. Input Keying Material&#10;&#10;```&#10;IKM_4G = K_ASME&#10;```&#10;(256 bits)&#10;&#10;### 6.3. Salt Construction&#10;&#10;```&#10;ctx = SNN || &quot;|&quot; || &quot;SMILE|4G|salt|v1&quot;&#10;Salt_4G = SHA256(ctx)&#10;```&#10;&#10;### 6.4. HKDF Derivation&#10;&#10;```&#10;Seed_4G = HKDF_SHA256(IKM_4G, Salt_4G, &quot;SMILE|4G|seed|v1&quot;)&#10;```&#10;&#10;### 6.5. Output&#10;&#10;- 32-byte BIP32 seed.&#10;- Strong cryptographic entropy, sourced from LTE authentication hierarchy.&#10;- Safe for generating HD wallet roots tied to mobile identity.&#10;&#10;---&#10;&#10;## 7. deriveBIP32MasterSeed5G&#10;&#10;### 7.1. Authentication Source&#10;&#10;5G AKA (TS 33.501) derives the following hierarchy:&#10;&#10;```&#10;K_AUSF = HMAC_SHA256(CK||IK, FC||SNN||L0||(SQN⊕AK)||L1), FC = 0x6A&#10;K_SEAF = HMAC_SHA256(K_AUSF, FC||SNN||L0), FC = 0x6B&#10;```&#10;&#10;### 7.2. Input Keying Material&#10;&#10;```&#10;IKM_5G = K_SEAF&#10;```&#10;&#10;### 7.3. Salt Construction&#10;&#10;```&#10;ctx = SNN || &quot;|&quot; || &quot;SMILE|5G|salt|v1&quot;&#10;Salt_5G = SHA256(ctx)&#10;```&#10;&#10;### 7.4. HKDF Derivation&#10;&#10;```&#10;Seed_5G = HKDF_SHA256(IKM_5G, Salt_5G, &quot;SMILE|5G|seed|v1&quot;)&#10;```&#10;&#10;### 7.5. Output&#10;&#10;- 32-byte master seed (BIP32 m/ root).&#10;- Entropy sourced from 5G key hierarchy (K_SEAF), which derives from K via CK/IK → K_AUSF → K_SEAF.&#10;- Represents cryptographic coupling between SIM identity and HD wallet seed.&#10;&#10;---&#10;&#10;## 8. Security Discussion&#10;&#10;1. **Entropy:**&#10;    - 2G: ≤ 96 bits&#10;    - 3G/4G/5G: ≥ 256 bits (AES-based + random challenge)&#10;&#10;2. **Forward Secrecy:**&#10;    - Each derivation depends on network RAND, ensuring session uniqueness.&#10;&#10;3. **Domain Separation:**&#10;    - HKDF salt and info labels include generation and versioning tags (SMILE|xG|...|v1).&#10;&#10;4. **Compatibility:**&#10;    - Final output format (32 bytes) matches BIP32 master seed input for:&#10;      ```&#10;      (m, c) = HMAC_SHA512(&quot;Bitcoin seed&quot;, Seed)&#10;      ```&#10;&#10;---&#10;&#10;## 9. Example End-to-End Derivation Flow (5G)&#10;&#10;```&#10;Step 1: AKA → CK, IK, AK, RES&#10;Step 2: K_AUSF = HMAC_SHA256(CK||IK, 0x6A||SNN||L0||(SQN⊕AK)||L1)&#10;Step 3: K_SEAF = HMAC_SHA256(K_AUSF, 0x6B||SNN||L0)&#10;Step 4: Salt = SHA256(SNN||&quot;|&quot;||&quot;SMILE|5G|salt|v1&quot;)&#10;Step 5: Seed = HKDF_SHA256(K_SEAF, Salt, &quot;SMILE|5G|seed|v1&quot;)&#10;Output: Seed_5G ∈ {0,1}^256&#10;```&#10;&#10;---&#10;&#10;## 10. Implementation Notes&#10;&#10;- All HKDF operations use HMAC-SHA256 as the PRF.&#10;- All salts and info strings are ASCII-encoded.&#10;- The seed output can be directly passed to BIP32 as the entropy input for HMAC-SHA512 keychain derivation.&#10;&#10;---&#10;&#10;## 11. Security Level Summary&#10;&#10;| Generation | Entropy Source | Algorithmic Base | Cryptographic Strength |&#10;|-------------|----------------|------------------|------------------------|&#10;| 2G | (SRES‖Kc) | COMP128 / A3/A8 | Weak / Legacy |&#10;| 3G | (CK‖IK) via Milenage | AES-128 | Strong |&#10;| 4G | K_ASME (HMAC-SHA256) | AES-128 + SHA256 | Strong |&#10;| 5G | K_SEAF (HMAC-SHA256 chain) | AES-128 + SHA256 | Very Strong |&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/external/libbtc/include/libbtc-config.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/external/libbtc/include/libbtc-config.h" />
              <option name="updatedContent" value="// Minimal libbtc-config.h for direct CMake build&#10;#ifndef LIBBTC_CONFIG_H&#10;#define LIBBTC_CONFIG_H&#10;&#10;#define HAVE_CONFIG_H 1&#10;#define PACKAGE_NAME &quot;libbtc&quot;&#10;#define PACKAGE_VERSION &quot;0.0.1&quot;&#10;#define STDC_HEADERS 1&#10;#define HAVE_DLFCN_H 1&#10;#define HAVE_INTTYPES_H 1&#10;#define HAVE_MEMORY_H 1&#10;#define HAVE_STDINT_H 1&#10;#define HAVE_STDLIB_H 1&#10;#define HAVE_STRINGS_H 1&#10;#define HAVE_STRING_H 1&#10;#define HAVE_SYS_STAT_H 1&#10;#define HAVE_SYS_TYPES_H 1&#10;#define HAVE_UNISTD_H 1&#10;&#10;#endif // LIBBTC_CONFIG_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Comp128.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Comp128.h" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="extern void comp128v1(const uint8_t *ki, const uint8_t *rand, uint8_t *sres, uint8_t *kc);&#10;extern void comp128(const uint8_t *ki, const uint8_t *rand, uint8_t *sres, uint8_t *kc);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Milenage.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Milenage.cpp" />
              <option name="updatedContent" value="#include &quot;Milenage.h&quot;&#10;#include &lt;openssl/aes.h&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;vector&gt;&#10;&#10;// Rijndael round constants&#10;static const uint8_t RCON[10] = {&#10;    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b&#10;};&#10;&#10;// Helper function to perform XOR on two byte arrays&#10;static void xor_128(const uint8_t* a, const uint8_t* b, uint8_t* out) {&#10;    for (int i = 0; i &lt; 16; ++i) {&#10;        out[i] = a[i] ^ b[i];&#10;    }&#10;}&#10;&#10;// The core Rijndael encryption function&#10;static void rijndael_encrypt(const uint8_t* key, const uint8_t* data, uint8_t* out) {&#10;    AES_KEY aes_key;&#10;    AES_set_encrypt_key(key, 128, &amp;aes_key);&#10;    AES_encrypt(data, out, &amp;aes_key);&#10;}&#10;&#10;void Milenage::run(const uint8_t* k, const uint8_t* opc, const uint8_t* rand, const uint8_t* sqn, const uint8_t* amf,&#10;                   uint8_t* res, uint8_t* ck, uint8_t* ik, uint8_t* ak, uint8_t* mac_a) {&#10;    uint8_t temp[16];&#10;    uint8_t in1[16];&#10;    uint8_t out1[16];&#10;    uint8_t c1[16] = {0};&#10;    uint8_t c2[16] = {0};&#10;    uint8_t c3[16] = {0};&#10;    uint8_t c4[16] = {0};&#10;    uint8_t c5[16] = {0};&#10;&#10;    c2[15] = 1;&#10;    c3[15] = 2;&#10;    c4[15] = 4;&#10;    c5[15] = 8;&#10;&#10;    // TEMP = E_K(RAND XOR OP_C)&#10;    xor_128(rand, opc, temp);&#10;    rijndael_encrypt(k, temp, out1);&#10;&#10;    // IN1 = SQN || AMF || SQN || AMF&#10;    memcpy(in1, sqn, 6);&#10;    memcpy(in1 + 6, amf, 2);&#10;    memcpy(in1 + 8, sqn, 6);&#10;    memcpy(in1 + 14, amf, 2);&#10;&#10;    // OUT1 = E_K(TEMP XOR IN1)&#10;    xor_128(out1, in1, temp);&#10;    rijndael_encrypt(k, temp, out1);&#10;    // MAC_A = f1 = OUT1[0..7]&#10;    memcpy(mac_a, out1, 8);&#10;&#10;    // RES, CK, IK, AK&#10;    // RES = f2 = OUT1[8..15]&#10;    xor_128(out1, c2, temp);&#10;    rijndael_encrypt(k, temp, out1);&#10;    memcpy(res, out1 + 8, 8);&#10;&#10;    // CK = f3 = OUT1[0..15]&#10;    xor_128(out1, c3, temp);&#10;    rijndael_encrypt(k, temp, ck);&#10;&#10;    // IK = f4 = OUT1[0..15]&#10;    xor_128(out1, c4, temp);&#10;    rijndael_encrypt(k, temp, ik);&#10;&#10;    // AK = f5 = OUT1[0..7]&#10;    xor_128(out1, c5, temp);&#10;    rijndael_encrypt(k, temp, out1);&#10;    memcpy(ak, out1, 6);&#10;}&#10;&#10;void Milenage::f1(const uint8_t* k, const uint8_t* rand, const uint8_t* sqn, const uint8_t* amf, const uint8_t* opc, uint8_t* mac_a, uint8_t* mac_s) {&#10;    // Not fully implemented as run() is used directly&#10;}&#10;&#10;void Milenage::f2345(const uint8_t* k, const uint8_t* rand, const uint8_t* opc, uint8_t* res, uint8_t* ck, uint8_t* ik, uint8_t* ak) {&#10;    // Not fully implemented as run() is used directly&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Milenage.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Milenage.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;cstdint&gt;&#10;#include &lt;vector&gt;&#10;&#10;class Milenage {&#10;public:&#10;    static void f1(const uint8_t* k, const uint8_t* rand, const uint8_t* sqn, const uint8_t* amf, const uint8_t* opc, uint8_t* mac_a, uint8_t* mac_s);&#10;    static void f2345(const uint8_t* k, const uint8_t* rand, const uint8_t* opc, uint8_t* res, uint8_t* ck, uint8_t* ik, uint8_t* ak);&#10;    static void run(const uint8_t* k, const uint8_t* opc, const uint8_t* rand, const uint8_t* sqn, const uint8_t* amf,&#10;                    uint8_t* res, uint8_t* ck, uint8_t* ik, uint8_t* ak, uint8_t* mac_a);&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/SimEmulator.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/SimEmulator.cpp" />
              <option name="originalContent" value="#include &quot;common.h&quot;&#10;#include &quot;CValues.h&quot;&#10;#include &quot;SimEmulator.h&quot;&#10;#include &quot;Milenage.h&quot;&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;tuple&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;cstring&gt;&#10;&#10;&#10;#include &quot;Aka2G.h&quot;&#10;&#10;&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;SimEmulator::authenticate2G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; ki)&#10;{&#10;    std::vector&lt;uint8_t&gt; sres(4);&#10;    std::vector&lt;uint8_t&gt; kc(8);&#10;    Aka2G::runAka(ki.data(), rand.data(), sres.data(), kc.data());&#10;    return {sres, kc};&#10;}&#10;&#10;&#10;std::tuple&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;,&#10;           std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;SimEmulator::authenticate3G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf)&#10;{&#10;&#10;    if (rand.size() != 16 || autn.size() != 16 ||&#10;        k.size() != 16 || opc.size() != 16 || amf.size() != 2)&#10;        throw std::invalid_argument(&quot;authenticate3G: invalid input sizes&quot;);&#10;&#10;    Block128 RAND, K, OPc, AMF{};&#10;    std::copy(rand.begin(), rand.end(), RAND.begin());&#10;    std::copy(k.begin(), k.end(), K.begin());&#10;    std::copy(opc.begin(), opc.end(), OPc.begin());&#10;    std::copy(amf.begin(), amf.end(), AMF.begin());&#10;&#10;    // Split AUTN fields: SQN ⊕ AK (6), AMF (2), MAC-A (8)&#10;    std::array&lt;uint8_t,6&gt; sqn_xor_ak{};&#10;    std::array&lt;uint8_t,8&gt; mac_a_received{};&#10;    std::memcpy(sqn_xor_ak.data(), autn.data(), 6);&#10;    std::memcpy(mac_a_received.data(), autn.data() + 8, 8);&#10;&#10;    // --- Step 1: Derive RES, CK, IK, AK from RAND ---&#10;    std::array&lt;uint8_t,8&gt; RES{};&#10;    Block128 CK{}, IK{};&#10;    std::array&lt;uint8_t,6&gt; AK{}, AKstar{};&#10;    f2345(K, RAND, OPc, RES, CK, IK, AK, AKstar);&#10;&#10;    // --- Step 2: Recover SQN = (SQN⊕AK)⊕AK ---&#10;    Block128 SQN{};&#10;    for (int i = 0; i &lt; 6; ++i)&#10;        SQN[i] = sqn_xor_ak[i] ^ AK[i];&#10;&#10;    // --- Step 3: Compute expected MAC-A using f1() ---&#10;    std::array&lt;uint8_t,8&gt; MAC_A{}, MAC_S{};&#10;    f1(K, RAND, SQN, AMF, OPc, MAC_A, MAC_S);&#10;&#10;    if (std::memcmp(MAC_A.data(), mac_a_received.data(), 8) != 0)&#10;        throw std::runtime_error(&quot;3G authentication failed: MAC mismatch&quot;);&#10;&#10;    // --- Step 4: Return success with (RES, CK, IK, AK) ---&#10;    return {&#10;        std::vector&lt;uint8_t&gt;(RES.begin(), RES.end()),&#10;        std::vector&lt;uint8_t&gt;(CK.begin(),  CK.end()),&#10;        std::vector&lt;uint8_t&gt;(IK.begin(),  IK.end()),&#10;        std::vector&lt;uint8_t&gt;(AK.begin(),  AK.end())&#10;    };&#10;}&#10;&#10;&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;SimEmulator::authenticate4G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                            const std::string&amp; snn)&#10;{&#10;    // Step 1: Perform 3G AKA&#10;    auto [res, ck, ik, ak] = authenticate3G(rand, autn, k, opc, amf);&#10;&#10;    // Step 2: Build KDF key = CK || IK&#10;    std::vector&lt;uint8_t&gt; kdf_key;&#10;    kdf_key.reserve(32);&#10;    kdf_key.insert(kdf_key.end(), ck.begin(), ck.end());&#10;    kdf_key.insert(kdf_key.end(), ik.begin(), ik.end());&#10;&#10;    // Step 3: Construct input string S for KDF (3GPP TS 33.401 §A.2.1)&#10;    // FC = 0x10 for K_ASME derivation&#10;    std::vector&lt;uint8_t&gt; s;&#10;    s.push_back(0x10);&#10;&#10;    // Parameter 0: SNN&#10;    s.insert(s.end(), snn.begin(), snn.end());&#10;    const uint16_t L0 = static_cast&lt;uint16_t&gt;(snn.size());&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L0 &gt;&gt; 8));&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L0 &amp; 0xFF));&#10;&#10;    // Parameter 1: SQN ⊕ AK (extracted from AUTN)&#10;    std::vector&lt;uint8_t&gt; sqn_xor_ak(autn.begin(), autn.begin() + 6);&#10;    const uint16_t L1 = static_cast&lt;uint16_t&gt;(sqn_xor_ak.size());&#10;    s.insert(s.end(), sqn_xor_ak.begin(), sqn_xor_ak.end());&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L1 &gt;&gt; 8));&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L1 &amp; 0xFF));&#10;&#10;    // Step 4: HMAC-SHA-256 key derivation&#10;    Block256 k_asme{};&#10;    unsigned int k_asme_len = 0;&#10;&#10;    if (!HMAC(EVP_sha256(), kdf_key.data(), static_cast&lt;int&gt;(kdf_key.size()),&#10;              s.data(), s.size(), k_asme.data(), &amp;k_asme_len))&#10;        throw std::runtime_error(&quot;HMAC computation failed&quot;);&#10;&#10;    if (k_asme_len != 32)&#10;        throw std::runtime_error(&quot;K_ASME length mismatch&quot;);&#10;&#10;    // Optional: cleanse sensitive memory&#10;    // OPENSSL_cleanse(kdf_key.data(), kdf_key.size());&#10;&#10;    return {res, k_asme};&#10;}&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;SimEmulator::authenticate5G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                            const std::string&amp; snn)&#10;{&#10;    // Step 1: Perform 3G AKA → RES, CK, IK, AK&#10;    auto [res, ck, ik, ak] = authenticate3G(rand, autn, k, opc, amf);&#10;&#10;    // Base key: CK || IK&#10;    std::vector&lt;uint8_t&gt; ck_ik;&#10;    ck_ik.reserve(32);&#10;    ck_ik.insert(ck_ik.end(), ck.begin(), ck.end());&#10;    ck_ik.insert(ck_ik.end(), ik.begin(), ik.end());&#10;&#10;    // --- Helper lambda to append a 16-bit big-endian length ---&#10;    auto append_len = [](std::vector&lt;uint8_t&gt;&amp; v, size_t len) {&#10;        v.push_back(static_cast&lt;uint8_t&gt;((len &gt;&gt; 8) &amp; 0xFF));&#10;        v.push_back(static_cast&lt;uint8_t&gt;(len &amp; 0xFF));&#10;    };&#10;&#10;    // Extract SQN⊕AK from AUTN (first 6 bytes)&#10;    std::vector&lt;uint8_t&gt; sqn_xor_ak(autn.begin(), autn.begin() + 6);&#10;&#10;    // ──────────────────────────────&#10;    // Step 2 – Derive K_AUSF (Annex A.4)&#10;    // S = FC || SNN || L0 || (SQN⊕AK) || L1&#10;    std::vector&lt;uint8_t&gt; s_kausf;&#10;    s_kausf.push_back(0x6A);  // FC&#10;    s_kausf.insert(s_kausf.end(), snn.begin(), snn.end());&#10;    append_len(s_kausf, snn.size());&#10;    s_kausf.insert(s_kausf.end(), sqn_xor_ak.begin(), sqn_xor_ak.end());&#10;    append_len(s_kausf, sqn_xor_ak.size());&#10;&#10;    Block256 k_ausf{};&#10;    unsigned int k_ausf_len = 0;&#10;    if (!HMAC(EVP_sha256(), ck_ik.data(), static_cast&lt;int&gt;(ck_ik.size()),&#10;              s_kausf.data(), s_kausf.size(), k_ausf.data(), &amp;k_ausf_len) ||&#10;        k_ausf_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive K_AUSF&quot;);&#10;&#10;    // ──────────────────────────────&#10;    // Step 3 – Derive K_SEAF (Annex A.5)&#10;    // S = FC || SNN || L0&#10;    std::vector&lt;uint8_t&gt; s_kseaf;&#10;    s_kseaf.push_back(0x6B);&#10;    s_kseaf.insert(s_kseaf.end(), snn.begin(), snn.end());&#10;    append_len(s_kseaf, snn.size());&#10;&#10;    Block256 k_seaf{};&#10;    unsigned int k_seaf_len = 0;&#10;    if (!HMAC(EVP_sha256(), k_ausf.data(), static_cast&lt;int&gt;(k_ausf.size()),&#10;              s_kseaf.data(), s_kseaf.size(), k_seaf.data(), &amp;k_seaf_len) ||&#10;        k_seaf_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive K_SEAF&quot;);&#10;&#10;    // ──────────────────────────────&#10;    // Step 4 – Derive RES* (Annex A.6)&#10;    // S = FC || SNN || L0 || RAND || L1 || RES || L2&#10;    std::vector&lt;uint8_t&gt; s_res_star;&#10;    s_res_star.push_back(0x6D);&#10;    s_res_star.insert(s_res_star.end(), snn.begin(), snn.end());&#10;    append_len(s_res_star, snn.size());&#10;    s_res_star.insert(s_res_star.end(), rand.begin(), rand.end());&#10;    append_len(s_res_star, rand.size());&#10;    s_res_star.insert(s_res_star.end(), res.begin(), res.end());&#10;    append_len(s_res_star, res.size());&#10;&#10;    std::array&lt;uint8_t, 32&gt; res_star_full{};&#10;    unsigned int res_star_len = 0;&#10;    if (!HMAC(EVP_sha256(), ck_ik.data(), static_cast&lt;int&gt;(ck_ik.size()),&#10;              s_res_star.data(), s_res_star.size(),&#10;              res_star_full.data(), &amp;res_star_len) ||&#10;        res_star_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive RES*&quot;);&#10;&#10;    // Rightmost 16 bytes = RES*&#10;    std::vector&lt;uint8_t&gt; res_star(res_star_full.end() - 16, res_star_full.end());&#10;&#10;    return {res_star, k_seaf};&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;common.h&quot;&#10;#include &quot;CValues.h&quot;&#10;#include &quot;SimEmulator.h&quot;&#10;#include &quot;Milenage.h&quot;&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;tuple&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;cstring&gt;&#10;&#10;&#10;#include &quot;Aka2G.h&quot;&#10;&#10;&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;SimEmulator::authenticate2G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; ki)&#10;{&#10;    std::vector&lt;uint8_t&gt; sres(4);&#10;    std::vector&lt;uint8_t&gt; kc(8);&#10;    Aka2G::runAka(ki.data(), rand.data(), sres.data(), kc.data());&#10;    return {sres, kc};&#10;}&#10;&#10;&#10;std::tuple&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;,&#10;           std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;SimEmulator::authenticate3G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf)&#10;{&#10;&#10;    if (rand.size() != 16 || autn.size() != 16 ||&#10;        k.size() != 16 || opc.size() != 16 || amf.size() != 2)&#10;        throw std::invalid_argument(&quot;authenticate3G: invalid input sizes&quot;);&#10;&#10;    Block128 RAND, K, OPc, AMF{};&#10;    std::copy(rand.begin(), rand.end(), RAND.begin());&#10;    std::copy(k.begin(), k.end(), K.begin());&#10;    std::copy(opc.begin(), opc.end(), OPc.begin());&#10;    std::copy(amf.begin(), amf.end(), AMF.begin());&#10;&#10;    // Split AUTN fields: SQN ⊕ AK (6), AMF (2), MAC-A (8)&#10;    std::array&lt;uint8_t,6&gt; sqn_xor_ak{};&#10;    std::array&lt;uint8_t,8&gt; mac_a_received{};&#10;    std::memcpy(sqn_xor_ak.data(), autn.data(), 6);&#10;    std::memcpy(mac_a_received.data(), autn.data() + 8, 8);&#10;&#10;    // --- Step 1: Derive RES, CK, IK, AK from RAND ---&#10;    std::array&lt;uint8_t,8&gt; RES{};&#10;    Block128 CK{}, IK{};&#10;    std::array&lt;uint8_t,6&gt; AK{}, AKstar{};&#10;    f2345(K, RAND, OPc, RES, CK, IK, AK, AKstar);&#10;&#10;    // --- Step 2: Recover SQN = (SQN⊕AK)⊕AK ---&#10;    Block128 SQN{};&#10;    for (int i = 0; i &lt; 6; ++i)&#10;        SQN[i] = sqn_xor_ak[i] ^ AK[i];&#10;&#10;    // --- Step 3: Compute expected MAC-A using f1() ---&#10;    std::array&lt;uint8_t,8&gt; MAC_A{}, MAC_S{};&#10;    f1(K, RAND, SQN, AMF, OPc, MAC_A, MAC_S);&#10;&#10;    if (std::memcmp(MAC_A.data(), mac_a_received.data(), 8) != 0)&#10;        throw std::runtime_error(&quot;3G authentication failed: MAC mismatch&quot;);&#10;&#10;    // --- Step 4: Return success with (RES, CK, IK, AK) ---&#10;    return {&#10;        std::vector&lt;uint8_t&gt;(RES.begin(), RES.end()),&#10;        std::vector&lt;uint8_t&gt;(CK.begin(),  CK.end()),&#10;        std::vector&lt;uint8_t&gt;(IK.begin(),  IK.end()),&#10;        std::vector&lt;uint8_t&gt;(AK.begin(),  AK.end())&#10;    };&#10;}&#10;&#10;&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;SimEmulator::authenticate4G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                            const std::string&amp; snn)&#10;{&#10;    // Step 1: Perform 3G AKA&#10;    auto [res, ck, ik, ak] = authenticate3G(rand, autn, k, opc, amf);&#10;&#10;    // Step 2: Build KDF key = CK || IK&#10;    std::vector&lt;uint8_t&gt; kdf_key;&#10;    kdf_key.reserve(32);&#10;    kdf_key.insert(kdf_key.end(), ck.begin(), ck.end());&#10;    kdf_key.insert(kdf_key.end(), ik.begin(), ik.end());&#10;&#10;    // Step 3: Construct input string S for KDF (3GPP TS 33.401 §A.2.1)&#10;    // FC = 0x10 for K_ASME derivation&#10;    std::vector&lt;uint8_t&gt; s;&#10;    s.push_back(0x10);&#10;&#10;    // Parameter 0: SNN&#10;    s.insert(s.end(), snn.begin(), snn.end());&#10;    const uint16_t L0 = static_cast&lt;uint16_t&gt;(snn.size());&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L0 &gt;&gt; 8));&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L0 &amp; 0xFF));&#10;&#10;    // Parameter 1: SQN ⊕ AK (extracted from AUTN)&#10;    std::vector&lt;uint8_t&gt; sqn_xor_ak(autn.begin(), autn.begin() + 6);&#10;    const uint16_t L1 = static_cast&lt;uint16_t&gt;(sqn_xor_ak.size());&#10;    s.insert(s.end(), sqn_xor_ak.begin(), sqn_xor_ak.end());&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L1 &gt;&gt; 8));&#10;    s.push_back(static_cast&lt;uint8_t&gt;(L1 &amp; 0xFF));&#10;&#10;    // Step 4: HMAC-SHA-256 key derivation&#10;    Block256 k_asme{};&#10;    unsigned int k_asme_len = 0;&#10;&#10;    if (!HMAC(EVP_sha256(), kdf_key.data(), static_cast&lt;int&gt;(kdf_key.size()),&#10;              s.data(), s.size(), k_asme.data(), &amp;k_asme_len))&#10;        throw std::runtime_error(&quot;HMAC computation failed&quot;);&#10;&#10;    if (k_asme_len != 32)&#10;        throw std::runtime_error(&quot;K_ASME length mismatch&quot;);&#10;&#10;    // Optional: cleanse sensitive memory&#10;    // OPENSSL_cleanse(kdf_key.data(), kdf_key.size());&#10;&#10;    return {res, k_asme};&#10;}&#10;&#10;std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;SimEmulator::authenticate5G(const std::vector&lt;uint8_t&gt;&amp; rand,&#10;                            const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                            const std::vector&lt;uint8_t&gt;&amp; k,&#10;                            const std::vector&lt;uint8_t&gt;&amp; opc,&#10;                            const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                            const std::string&amp; snn)&#10;{&#10;    // Step 1: Perform 3G AKA → RES, CK, IK, AK&#10;    auto [res, ck, ik, ak] = authenticate3G(rand, autn, k, opc, amf);&#10;&#10;    // Base key: CK || IK&#10;    std::vector&lt;uint8_t&gt; ck_ik;&#10;    ck_ik.reserve(32);&#10;    ck_ik.insert(ck_ik.end(), ck.begin(), ck.end());&#10;    ck_ik.insert(ck_ik.end(), ik.begin(), ik.end());&#10;&#10;    // --- Helper lambda to append a 16-bit big-endian length ---&#10;    auto append_len = [](std::vector&lt;uint8_t&gt;&amp; v, size_t len) {&#10;        v.push_back(static_cast&lt;uint8_t&gt;((len &gt;&gt; 8) &amp; 0xFF));&#10;        v.push_back(static_cast&lt;uint8_t&gt;(len &amp; 0xFF));&#10;    };&#10;&#10;    // Extract SQN⊕AK from AUTN (first 6 bytes)&#10;    std::vector&lt;uint8_t&gt; sqn_xor_ak(autn.begin(), autn.begin() + 6);&#10;&#10;    // ──────────────────────────────&#10;    // Step 2 – Derive K_AUSF (Annex A.4)&#10;    // S = FC || SNN || L0 || (SQN⊕AK) || L1&#10;    std::vector&lt;uint8_t&gt; s_kausf;&#10;    s_kausf.push_back(0x6A);  // FC&#10;    s_kausf.insert(s_kausf.end(), snn.begin(), snn.end());&#10;    append_len(s_kausf, snn.size());&#10;    s_kausf.insert(s_kausf.end(), sqn_xor_ak.begin(), sqn_xor_ak.end());&#10;    append_len(s_kausf, sqn_xor_ak.size());&#10;&#10;    Block256 k_ausf{};&#10;    unsigned int k_ausf_len = 0;&#10;    if (!HMAC(EVP_sha256(), ck_ik.data(), static_cast&lt;int&gt;(ck_ik.size()),&#10;              s_kausf.data(), s_kausf.size(), k_ausf.data(), &amp;k_ausf_len) ||&#10;        k_ausf_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive K_AUSF&quot;);&#10;&#10;    // ──────────────────────────────&#10;    // Step 3 – Derive K_SEAF (Annex A.5)&#10;    // S = FC || SNN || L0&#10;    std::vector&lt;uint8_t&gt; s_kseaf;&#10;    s_kseaf.push_back(0x6B);&#10;    s_kseaf.insert(s_kseaf.end(), snn.begin(), snn.end());&#10;    append_len(s_kseaf, snn.size());&#10;&#10;    Block256 k_seaf{};&#10;    unsigned int k_seaf_len = 0;&#10;    if (!HMAC(EVP_sha256(), k_ausf.data(), static_cast&lt;int&gt;(k_ausf.size()),&#10;              s_kseaf.data(), s_kseaf.size(), k_seaf.data(), &amp;k_seaf_len) ||&#10;        k_seaf_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive K_SEAF&quot;);&#10;&#10;    // ──────────────────────────────&#10;    // Step 4 – Derive RES* (Annex A.6)&#10;    // S = FC || SNN || L0 || RAND || L1 || RES || L2&#10;    std::vector&lt;uint8_t&gt; s_res_star;&#10;    s_res_star.push_back(0x6D);&#10;    s_res_star.insert(s_res_star.end(), snn.begin(), snn.end());&#10;    append_len(s_res_star, snn.size());&#10;    s_res_star.insert(s_res_star.end(), rand.begin(), rand.end());&#10;    append_len(s_res_star, rand.size());&#10;    s_res_star.insert(s_res_star.end(), res.begin(), res.end());&#10;    append_len(s_res_star, res.size());&#10;&#10;    std::array&lt;uint8_t, 32&gt; res_star_full{};&#10;    unsigned int res_star_len = 0;&#10;    if (!HMAC(EVP_sha256(), ck_ik.data(), static_cast&lt;int&gt;(ck_ik.size()),&#10;              s_res_star.data(), s_res_star.size(),&#10;              res_star_full.data(), &amp;res_star_len) ||&#10;        res_star_len != 32)&#10;        throw std::runtime_error(&quot;Failed to derive RES*&quot;);&#10;&#10;    // Rightmost 16 bytes = RES*&#10;    std::vector&lt;uint8_t&gt; res_star(res_star_full.end() - 16, res_star_full.end());&#10;&#10;    return {res_star, k_seaf};&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/SimEmulator.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/SimEmulator.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;&#10;#include &quot;Milenage.h&quot;&#10;&#10;class SimEmulator {&#10;public:&#10;    /**&#10;     * @brief Performs 2G (GSM) authentication using the COMP128-1 algorithm.&#10;     *&#10;     * This function simulates the authentication process of a 2G SIM card. It takes a random&#10;     * challenge (RAND) from the network and the secret key (Ki) from the SIM, and computes&#10;     * the Signed Response (SRES) and the Ciphering Key (Kc).&#10;     *&#10;     * @param rand A 16-byte (128-bit) random challenge from the network.&#10;     * @param ki A 16-byte (128-bit) secret key stored on the SIM card.&#10;     * @return A pair containing the 4-byte SRES and the 8-byte Kc.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;    authenticate2G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; ki);&#10;&#10;    /**&#10;     * @brief Performs 3G (UMTS) authentication using the Milenage algorithm.&#10;     *&#10;     * This function simulates the 3G authentication and key agreement (AKA) procedure. It takes&#10;     * a random challenge (RAND), an Authentication Token (AUTN), the secret key (K), the Operator&#10;     * Variant Algorithm Configuration Field (OPc), and the Authentication Management Field (AMF).&#10;     * It verifies the AUTN and, if successful, computes the Response (RES), Cipher Key (CK),&#10;     * Integrity Key (IK), and Anonymity Key (AK).&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @return A tuple containing the RES, CK, IK, and AK.&#10;     */&#10;    static std::tuple&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;    authenticate3G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf);&#10;&#10;    /**&#10;     * @brief Performs 4G (LTE) Evolved Packet System (EPS) authentication (EPS-AKA).&#10;     *&#10;     * This function builds on 3G AKA to perform 4G authentication. It takes the same parameters&#10;     * as 3G AKA, plus the Serving Network Name (SNN). It first runs the 3G authentication&#10;     * process to generate RES, CK, and IK. It then uses CK and IK to derive the K_ASME&#10;     * (Key for Access Security Management Entity) as specified in 3GPP TS 33.401.&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @param snn The Serving Network Name, used in the key derivation process.&#10;     * @return A pair containing the 8-byte RES and the 32-byte K_ASME.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;    authenticate4G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                   const std::string&amp; snn);&#10;&#10;    /**&#10;     * @brief Performs 5G authentication and key agreement (5G-AKA).&#10;     *&#10;     * This function simulates the 5G AKA procedure as specified in 3GPP TS 33.501. It starts&#10;     * by performing a 3G AKA authentication to obtain RES, CK, and IK. It then uses these&#10;     * keys and the Serving Network Name (SNN) to derive the 5G keys: K_AUSF (Key for the&#10;     * Authentication Server Function) and K_SEAF (Key for the Security Anchor Function).&#10;     * Finally, it computes the 5G response, RES*.&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @param snn The Serving Network Name, used in the key derivation process.&#10;     * @return A pair containing the 16-byte RES* and the 32-byte K_SEAF.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;    authenticate5G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                   const std::string&amp; snn);&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;&#10;&#10;#include &quot;Milenage.h&quot;&#10;&#10;class SimEmulator {&#10;public:&#10;    /**&#10;     * @brief Performs 2G (GSM) authentication using the COMP128-1 algorithm.&#10;     *&#10;     * This function simulates the authentication process of a 2G SIM card. It takes a random&#10;     * challenge (RAND) from the network and the secret key (Ki) from the SIM, and computes&#10;     * the Signed Response (SRES) and the Ciphering Key (Kc).&#10;     *&#10;     * @param rand A 16-byte (128-bit) random challenge from the network.&#10;     * @param ki A 16-byte (128-bit) secret key stored on the SIM card.&#10;     * @return A pair containing the 4-byte SRES and the 8-byte Kc.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;    authenticate2G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; ki);&#10;&#10;    /**&#10;     * @brief Derives a 256-bit seed from 2G authentication outputs.&#10;     *&#10;     * This function performs a 2G authentication and then securely hashes the resulting&#10;     * SRES and Kc values using SHA-256 to produce a 256-bit seed.&#10;     *&#10;     * @param rand A 16-byte (128-bit) random challenge from the network.&#10;     * @param ki A 16-byte (128-bit) secret key stored on the SIM card.&#10;     * @return A 256-bit (32-byte) seed as a std::array.&#10;     */&#10;    static Block256 deriveSeed2G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; ki);&#10;&#10;    /**&#10;     * @brief Performs 3G (UMTS) authentication using the Milenage algorithm.&#10;     *&#10;     * This function simulates the 3G authentication and key agreement (AKA) procedure. It takes&#10;     * a random challenge (RAND), an Authentication Token (AUTN), the secret key (K), the Operator&#10;     * Variant Algorithm Configuration Field (OPc), and the Authentication Management Field (AMF).&#10;     * It verifies the AUTN and, if successful, computes the Response (RES), Cipher Key (CK),&#10;     * Integrity Key (IK), and Anonymity Key (AK).&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @return A tuple containing the RES, CK, IK, and AK.&#10;     */&#10;    static std::tuple&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt;&#10;    authenticate3G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf);&#10;&#10;    /**&#10;     * @brief Performs 4G (LTE) Evolved Packet System (EPS) authentication (EPS-AKA).&#10;     *&#10;     * This function builds on 3G AKA to perform 4G authentication. It takes the same parameters&#10;     * as 3G AKA, plus the Serving Network Name (SNN). It first runs the 3G authentication&#10;     * process to generate RES, CK, and IK. It then uses CK and IK to derive the K_ASME&#10;     * (Key for Access Security Management Entity) as specified in 3GPP TS 33.401.&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @param snn The Serving Network Name, used in the key derivation process.&#10;     * @return A pair containing the 8-byte RES and the 32-byte K_ASME.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;    authenticate4G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                   const std::string&amp; snn);&#10;&#10;    /**&#10;     * @brief Performs 5G authentication and key agreement (5G-AKA).&#10;     *&#10;     * This function simulates the 5G AKA procedure as specified in 3GPP TS 33.501. It starts&#10;     * by performing a 3G AKA authentication to obtain RES, CK, and IK. It then uses these&#10;     * keys and the Serving Network Name (SNN) to derive the 5G keys: K_AUSF (Key for the&#10;     * Authentication Server Function) and K_SEAF (Key for the Security Anchor Function).&#10;     * Finally, it computes the 5G response, RES*.&#10;     *&#10;     * @param rand A 16-byte random challenge.&#10;     * @param autn A 16-byte authentication token from the network.&#10;     * @param k A 16-byte secret key.&#10;     * @param opc A 16-byte operator variant configuration field.&#10;     * @param amf A 2-byte authentication management field.&#10;     * @param snn The Serving Network Name, used in the key derivation process.&#10;     * @return A pair containing the 16-byte RES* and the 32-byte K_SEAF.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, Block256&gt;&#10;    authenticate5G(const std::vector&lt;uint8_t&gt;&amp; rand, const std::vector&lt;uint8_t&gt;&amp; autn,&#10;                   const std::vector&lt;uint8_t&gt;&amp; k, const std::vector&lt;uint8_t&gt;&amp; opc, const std::vector&lt;uint8_t&gt;&amp; amf,&#10;                   const std::string&amp; snn);&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Wallet.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Wallet.cpp" />
              <option name="originalContent" value="#include &quot;Wallet.h&quot;&#10;#include &quot;common.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &lt;cstring&gt; // For strlen&#10;&#10;// Helper: print bytes as hex&#10;static void print_hex(const std::string&amp; label, const std::vector&lt;uint8_t&gt;&amp; data) {&#10;    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; label &lt;&lt; &quot;: &quot;;&#10;    for (auto b : data) std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)b;&#10;    std::cout &lt;&lt; std::dec &lt;&lt; std::endl;&#10;}&#10;&#10;static std::pair&lt;Block256, Block256&gt; bip32_master_key(const Block256&amp; seed) {&#10;    static constexpr char key[] = &quot;Bitcoin seed&quot;;&#10;    unsigned int outlen = 64;&#10;    std::array&lt;uint8_t, 64&gt; out{};&#10;&#10;    unsigned char* result = HMAC(&#10;        EVP_sha512(),&#10;        key, sizeof(key) - 1,&#10;        seed.data(), seed.size(),&#10;        out.data(), &amp;outlen&#10;    );&#10;&#10;    if (!result || outlen != 64) {&#10;        throw std::runtime_error(&quot;HMAC-SHA512 failed&quot;);&#10;    }&#10;&#10;    Block256 privkey, chaincode;&#10;    std::memcpy(privkey.data(), out.data(), 32);&#10;    std::memcpy(chaincode.data(), out.data() + 32, 32);&#10;&#10;    if (!is_valid_secp256k1_key(privkey)) {&#10;        throw std::runtime_error(&quot;Invalid master private key (IL out of range)&quot;);&#10;    }&#10;&#10;    return {privkey, chaincode};&#10;}&#10;&#10;&#10;std::pair&lt;Block256, Block256&gt; Wallet::deriveMaster(const Block256&amp; seed) {&#10;    return bip32_master_key(seed);&#10;}" />
              <option name="updatedContent" value="#include &quot;Wallet.h&quot;&#10;#include &quot;common.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &lt;cstring&gt; // For strlen&#10;#include &lt;algorithm&gt; // For std::all_of&#10;&#10;// Helper: print bytes as hex&#10;static void print_hex(const std::string&amp; label, const std::vector&lt;uint8_t&gt;&amp; data) {&#10;    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; label &lt;&lt; &quot;: &quot;;&#10;    for (auto b : data) std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)b;&#10;    std::cout &lt;&lt; std::dec &lt;&lt; std::endl;&#10;}&#10;&#10;// The order of the secp256k1 curve&#10;static const Block256 SECP256K1_ORDER = {&#10;    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,&#10;    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,&#10;    0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,&#10;    0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41&#10;};&#10;&#10;// A private key is valid if it is not 0 and is less than the curve order n.&#10;static bool is_valid_secp256k1_key(const Block256&amp; privkey) {&#10;    bool is_zero = std::all_of(privkey.begin(), privkey.end(), [](uint8_t b) { return b == 0; });&#10;    if (is_zero) {&#10;        return false;&#10;    }&#10;&#10;    // memcmp returns &lt; 0 if first arg is less than second&#10;    return std::memcmp(privkey.data(), SECP256K1_ORDER.data(), 32) &lt; 0;&#10;}&#10;&#10;static std::pair&lt;Block256, Block256&gt; bip32_master_key(const Block256&amp; seed) {&#10;    static constexpr char key[] = &quot;Bitcoin seed&quot;;&#10;    unsigned int outlen = 64;&#10;    std::array&lt;uint8_t, 64&gt; out{};&#10;&#10;    unsigned char* result = HMAC(&#10;        EVP_sha512(),&#10;        key, sizeof(key) - 1,&#10;        seed.data(), seed.size(),&#10;        out.data(), &amp;outlen&#10;    );&#10;&#10;    if (!result || outlen != 64) {&#10;        throw std::runtime_error(&quot;HMAC-SHA512 failed&quot;);&#10;    }&#10;&#10;    Block256 privkey, chaincode;&#10;    std::memcpy(privkey.data(), out.data(), 32);&#10;    std::memcpy(chaincode.data(), out.data() + 32, 32);&#10;&#10;    if (!is_valid_secp256k1_key(privkey)) {&#10;        throw std::runtime_error(&quot;Invalid master private key (IL out of range)&quot;);&#10;    }&#10;&#10;    return {privkey, chaincode};&#10;}&#10;&#10;&#10;std::pair&lt;Block256, Block256&gt; Wallet::deriveMaster(const Block256&amp; seed) {&#10;    return bip32_master_key(seed);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Wallet.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Wallet.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;&#10;class Wallet {&#10;public:&#10;    /**&#10;     * @brief Derives the master key from a given seed using BIP39.&#10;     *&#10;     * This function takes a seed (typically derived from a mnemonic phrase) and&#10;     * uses it to generate a master private key for a hierarchical deterministic (HD)&#10;     * wallet, following the BIP39 standard. The resulting master key can then be&#10;     * used to derive child keys.&#10;     *&#10;     * @param seed A vector of bytes representing the seed. The seed should be&#10;     *             between 128 and 512 bits (16 to 64 bytes).&#10;     * @return A pair containing the 32-byte master private key and the 32-byte chain code.&#10;     */&#10;    static std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt; deriveMaster(const std::vector&lt;uint8_t&gt;&amp; seed);&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &quot;common.h&quot;&#10;&#10;class Wallet {&#10;public:&#10;    /**&#10;     * @brief Derives the master key from a given seed using BIP32.&#10;     *&#10;     * This function takes a 256-bit (32-byte) seed and uses it to generate a&#10;     * master private key and chain code for a hierarchical deterministic (HD)&#10;     * wallet, following the BIP32 standard.&#10;     *&#10;     * @param seed A 256-bit (32-byte) seed.&#10;     * @return A pair containing the 32-byte master private key and the 32-byte chain code.&#10;     */&#10;    static std::pair&lt;Block256, Block256&gt; deriveMaster(const Block256&amp; seed);&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/common.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/common.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;array&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;cstdint&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;string&gt;&#10;#include &lt;utility&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/kdf.h&gt;&#10;&#10;using Block128 = std::array&lt;uint8_t, 16&gt;;&#10;using Block256 = std::array&lt;uint8_t, 32&gt;;&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;array&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;cstdint&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;string&gt;&#10;#include &lt;utility&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/kdf.h&gt;&#10;&#10;using Block128 = std::array&lt;uint8_t, 16&gt;;&#10;using Block256 = std::array&lt;uint8_t, 32&gt;;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/comp128_table.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/comp128_table.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;cstdint&gt;&#10;&#10;// COMP128-1 substitution table (from public GSM reverse engineering)&#10;extern const uint8_t comp_128_tab[512];&#10;&#10;" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;cstdint&gt;&#10;&#10;class Comp128Table {&#10;public:&#10;    static const uint8_t table[512];&#10;    // Optionally, add static helper methods here if needed&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.cpp" />
              <option name="originalContent" value="#include &quot;Sim.h&quot;&#10;#include &quot;kdf.h&quot;&#10;#include &quot;Wallet.h&quot;&#10;#include &lt;nlohmann/json.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;&#10;int main() {&#10;    SIM sim;&#10;    if (!sim.connect()) {&#10;        std::cerr &lt;&lt; &quot;Failed to connect to SIM.\n&quot;;&#10;        return 1;&#10;    }&#10;&#10;    auto aka = sim.authenticate({0x00, 0x11, 0x22, 0x33}, {0x44, 0x55});&#10;    if (!aka) {&#10;        std::cerr &lt;&lt; &quot;AUTHENTICATE failed.\n&quot;;&#10;        return 1;&#10;    }&#10;&#10;    // Z = CK || IK&#10;    std::vector&lt;uint8_t&gt; Z = aka-&gt;ck;&#10;    Z.insert(Z.end(), aka-&gt;ik.begin(), aka-&gt;ik.end());&#10;&#10;    std::vector&lt;uint8_t&gt; salt = {0x00};&#10;    auto prk = hkdf_extract(salt, Z);&#10;    auto seed = hkdf_expand(prk, &quot;SMILE|AKA-&gt;BIP|seed|v1&quot;, 64);&#10;&#10;    Wallet::deriveMaster(seed);&#10;    sim.disconnect();&#10;&#10;    nlohmann::json j;&#10;    j[&quot;status&quot;] = &quot;ok&quot;;&#10;    j[&quot;seed_hex&quot;] = nlohmann::json::binary(seed);&#10;    std::cout &lt;&lt; j.dump(2) &lt;&lt; &quot;\n&quot;;&#10;&#10;    return 0;&#10;}" />
              <option name="updatedContent" value="#include &quot;Sim.h&quot;&#10;#include &quot;kdf.h&quot;&#10;#include &quot;Wallet.h&quot;&#10;#include &lt;nlohmann/json.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;&#10;int main() {&#10;    SIM sim;&#10;    if (!sim.connect()) {&#10;        std::cerr &lt;&lt; &quot;Failed to connect to SIM.\n&quot;;&#10;        return 1;&#10;    }&#10;&#10;    auto aka = sim.authenticate({0x00, 0x11, 0x22, 0x33}, {0x44, 0x55});&#10;    if (!aka) {&#10;        std::cerr &lt;&lt; &quot;AUTHENTICATE failed.\n&quot;;&#10;        return 1;&#10;    }&#10;&#10;    // Z = CK || IK&#10;    std::vector&lt;uint8_t&gt; Z = aka-&gt;ck;&#10;    Z.insert(Z.end(), aka-&gt;ik.begin(), aka-&gt;ik.end());&#10;&#10;    std::vector&lt;uint8_t&gt; salt = {0x00};&#10;    auto prk = hkdf_extract(salt, Z);&#10;    auto seed_vec = hkdf_expand(prk, &quot;SMILE|AKA-&gt;BIP|seed|v1&quot;, 32);&#10;&#10;    Block256 seed;&#10;    std::copy(seed_vec.begin(), seed_vec.end(), seed.begin());&#10;&#10;    Wallet::deriveMaster(seed);&#10;    sim.disconnect();&#10;&#10;    nlohmann::json j;&#10;    j[&quot;status&quot;] = &quot;ok&quot;;&#10;    j[&quot;seed_hex&quot;] = nlohmann::json::binary(seed_vec);&#10;    std::cout &lt;&lt; j.dump(2) &lt;&lt; &quot;\n&quot;;&#10;&#10;    return 0;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/smile_kdf.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/smile_kdf.cpp" />
              <option name="originalContent" value="#include &quot;smile_kdf.h&quot;&#10;#include &lt;openssl/kdf.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;stdexcept&gt;&#10;&#10;std::vector&lt;uint8_t&gt; smile_hkdf_extract(const std::vector&lt;uint8_t&gt;&amp; salt,&#10;                                        const std::vector&lt;uint8_t&gt;&amp; ikm) {&#10;    EVP_PKEY_CTX* pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr);&#10;    if (!pctx) throw std::runtime_error(&quot;EVP_PKEY_CTX_new_id failed&quot;);&#10;&#10;    std::vector&lt;uint8_t&gt; prk(32);&#10;    if (EVP_PKEY_derive_init(pctx) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set_hkdf_md(pctx, EVP_sha256()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_salt(pctx, salt.data(), salt.size()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_key(pctx, ikm.data(), ikm.size()) &lt;= 0 ||&#10;        EVP_PKEY_derive(pctx, prk.data(), &amp;((size_t){prk.size()})) &lt;= 0) {&#10;        EVP_PKEY_CTX_free(pctx);&#10;        throw std::runtime_error(&quot;HKDF-Extract failed&quot;);&#10;        }&#10;&#10;    EVP_PKEY_CTX_free(pctx);&#10;    return prk;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; smile_hkdf_expand(const std::vector&lt;uint8_t&gt;&amp; prk,&#10;                                       const std::string&amp; info,&#10;                                       size_t L) {&#10;    EVP_PKEY_CTX* pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr);&#10;    if (!pctx) throw std::runtime_error(&quot;EVP_PKEY_CTX_new_id failed&quot;);&#10;&#10;    std::vector&lt;uint8_t&gt; out(L);&#10;    if (EVP_PKEY_derive_init(pctx) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set_hkdf_md(pctx, EVP_sha256()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_key(pctx, prk.data(), prk.size()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_add1_hkdf_info(pctx, reinterpret_cast&lt;const unsigned char*&gt;(info.data()), info.size()) &lt;= 0 ||&#10;        EVP_PKEY_derive(pctx, out.data(), &amp;L) &lt;= 0) {&#10;        EVP_PKEY_CTX_free(pctx);&#10;        throw std::runtime_error(&quot;HKDF-Expand failed&quot;);&#10;        }&#10;&#10;    EVP_PKEY_CTX_free(pctx);&#10;    return out;&#10;}" />
              <option name="updatedContent" value="#include &quot;smile_kdf.h&quot;&#10;#include &lt;openssl/kdf.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;stdexcept&gt;&#10;&#10;std::vector&lt;uint8_t&gt; smile_hkdf_extract(const std::vector&lt;uint8_t&gt;&amp; salt,&#10;                                        const std::vector&lt;uint8_t&gt;&amp; ikm) {&#10;    EVP_PKEY_CTX* pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr);&#10;    if (!pctx) throw std::runtime_error(&quot;EVP_PKEY_CTX_new_id failed&quot;);&#10;&#10;    std::vector&lt;uint8_t&gt; prk(32);&#10;    size_t prk_len = prk.size();&#10;    if (EVP_PKEY_derive_init(pctx) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set_hkdf_md(pctx, EVP_sha256()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_salt(pctx, salt.data(), salt.size()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_key(pctx, ikm.data(), ikm.size()) &lt;= 0 ||&#10;        EVP_PKEY_derive(pctx, prk.data(), &amp;prk_len) &lt;= 0) {&#10;        EVP_PKEY_CTX_free(pctx);&#10;        throw std::runtime_error(&quot;HKDF-Extract failed&quot;);&#10;        }&#10;&#10;    EVP_PKEY_CTX_free(pctx);&#10;    return prk;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; smile_hkdf_expand(const std::vector&lt;uint8_t&gt;&amp; prk,&#10;                                       const std::string&amp; info,&#10;                                       size_t L) {&#10;    EVP_PKEY_CTX* pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr);&#10;    if (!pctx) throw std::runtime_error(&quot;EVP_PKEY_CTX_new_id failed&quot;);&#10;&#10;    std::vector&lt;uint8_t&gt; out(L);&#10;    if (EVP_PKEY_derive_init(pctx) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set_hkdf_md(pctx, EVP_sha256()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_set1_hkdf_key(pctx, prk.data(), prk.size()) &lt;= 0 ||&#10;        EVP_PKEY_CTX_add1_hkdf_info(pctx, reinterpret_cast&lt;const unsigned char*&gt;(info.data()), info.size()) &lt;= 0 ||&#10;        EVP_PKEY_derive(pctx, out.data(), &amp;L) &lt;= 0) {&#10;        EVP_PKEY_CTX_free(pctx);&#10;        throw std::runtime_error(&quot;HKDF-Expand failed&quot;);&#10;        }&#10;&#10;    EVP_PKEY_CTX_free(pctx);&#10;    return out;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/smile_wallet.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/smile_wallet.cpp" />
              <option name="originalContent" value="#include &quot;smile_wallet.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;&#10;// Helper: print bytes as hex&#10;static void print_hex(const std::string&amp; label, const std::vector&lt;uint8_t&gt;&amp; data) {&#10;    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; label &lt;&lt; &quot;: &quot;;&#10;    for (auto b : data) std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)b;&#10;    std::cout &lt;&lt; std::dec &lt;&lt; std::endl;&#10;}&#10;&#10;// Implements BIP-32 master key derivation (returns privkey + chaincode)&#10;static std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt; bip32_master_key(const std::vector&lt;uint8_t&gt;&amp; seed) {&#10;    const char* key = &quot;Bitcoin seed&quot;;&#10;    unsigned int outlen = 64;&#10;    std::vector&lt;uint8_t&gt; out(64);&#10;    HMAC(EVP_sha512(), key, strlen(key), seed.data(), seed.size(), out.data(), &amp;outlen);&#10;    std::vector&lt;uint8_t&gt; privkey(out.begin(), out.begin() + 32);&#10;    std::vector&lt;uint8_t&gt; chaincode(out.begin() + 32, out.end());&#10;    return {privkey, chaincode};&#10;}&#10;&#10;void SmileWallet::derive_master(const std::vector&lt;uint8_t&gt;&amp; seed) {&#10;    auto [privkey, chaincode] = bip32_master_key(seed);&#10;    std::cout &lt;&lt; &quot;[SMILE] Derived master key (BIP-32):\n&quot;;&#10;    print_hex(&quot;privkey&quot;, privkey);&#10;    print_hex(&quot;chaincode&quot;, chaincode);&#10;}" />
              <option name="updatedContent" value="#include &quot;smile_wallet.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;iomanip&gt;&#10;#include &lt;openssl/hmac.h&gt;&#10;#include &lt;openssl/evp.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &lt;cstring&gt; // For strlen&#10;&#10;// Helper: print bytes as hex&#10;static void print_hex(const std::string&amp; label, const std::vector&lt;uint8_t&gt;&amp; data) {&#10;    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; label &lt;&lt; &quot;: &quot;;&#10;    for (auto b : data) std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)b;&#10;    std::cout &lt;&lt; std::dec &lt;&lt; std::endl;&#10;}&#10;&#10;// Implements BIP-32 master key derivation (returns privkey + chaincode)&#10;static std::pair&lt;std::vector&lt;uint8_t&gt;, std::vector&lt;uint8_t&gt;&gt; bip32_master_key(const std::vector&lt;uint8_t&gt;&amp; seed) {&#10;    const char* key = &quot;Bitcoin seed&quot;;&#10;    unsigned int outlen = 64;&#10;    std::vector&lt;uint8_t&gt; out(64);&#10;    HMAC(EVP_sha512(), key, strlen(key), seed.data(), seed.size(), out.data(), &amp;outlen);&#10;    std::vector&lt;uint8_t&gt; privkey(out.begin(), out.begin() + 32);&#10;    std::vector&lt;uint8_t&gt; chaincode(out.begin() + 32, out.end());&#10;    return {privkey, chaincode};&#10;}&#10;&#10;void SmileWallet::derive_master(const std::vector&lt;uint8_t&gt;&amp; seed) {&#10;    auto [privkey, chaincode] = bip32_master_key(seed);&#10;    std::cout &lt;&lt; &quot;[SMILE] Derived master key (BIP-32):\n&quot;;&#10;    print_hex(&quot;privkey&quot;, privkey);&#10;    print_hex(&quot;chaincode&quot;, chaincode);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>